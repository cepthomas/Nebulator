
// Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.


/*
--------------------------------------------------------------------
Types of contrapuntal motion

In parallel motion, two voices move in the same direction by the same generic interval. For example, the following two voices both move up by a step. Note also that both dyads form the same generic interval (sixth). This will always be true when two voices move in parallel motion.

In similar motion, also called direct motion, two voices move in the same direction, but by different intervals. For example, the following two voices both move down, but the upper voice moves by step while the lower voice moves by leap. Note also that the two dyads are different generic intervals. This will always be the case with similar or direct motion.

In contrary motion, two voices move in opposite directionsâ€”one up, the other down.

In oblique motion, one voice is stationary, while the other voice moves (in either direction). The stationary tone may or may not be rearticulated.

--------------------------------------------------------------------
Generative Music becomes Reflective Music when your text can be used as a seed for how it starts.
http://spheric-lounge-live-ambient-music.blogspot.com/

The random item stream pattern type uses the optional keyword :weight to alter the probability of an event being selected in relation to the other events in the item stream.
>>> need this, for scale note selections.

The graph item stream pattern type creates an item stream of user-specified rules for traversing a series of nodes called a graph.
>>> my loops - rules to change/transition.

Sonification uses data that is typically not musical and involves remapping this to musical parameters to create a composition.

---------------------------------------------------------------------
Phasing by playing e.g. six loops with different durations - sync/phase.

Random note/Octave Shifts, Instrumentation, etc...
How Phase Music Works
And now we come to the real technical trick that underlies "It's Gonna Rain": What we are hearing are two identical tape loops playing at the same time. There's one in the left ear and one in the right. But one of those loops is running ever so slightly faster than the other.
The difference is so small you don't even notice it at first, but after a while it amounts to a phase shift between the two loops that keeps growing bigger and bigger as time goes by. First it sounds like there's an echo. Then the echo transforms into a repeating effect, and then it builds into a series of strange combinations of sounds as different parts of the sample overlap with others. At the halfway point the loops start to approach each other again, and we go back through repetition and echo to unison.

--------------------------------------------------------------------
http://www.auralfractals.net/about/

The Generators are a series of algorithms used for creating musical compositions. They generate the base pattern seed from diverse 
procedural methods, such as fractals (The Lyapunov Generators, Random Walks, etc), Cellular Automatas (Heat CA, Harmonic Oscillators), or musical rules (Tone Walks).

The generators can be accessed from the Base Pattern Editor.

AI Inverse Pentatonic: AI Generator over the pentatonic scale with tonal inversion
AI Inverse Scale:: AI Generator over the selected tones with tonal inversion
AI Inverse: AI Generator over white notes with tonal inversion
AI Pentatonic: Artificial Intelligence Generator over the pentatonic scale
AI Scale: Artificial Intelligence Generator over the selected tones
AI White Notes: Artificial Intelligence Generator over white notes
Cellular Automata I: Notes comes from the cell values of the Heat Cellular Automata.
Cellular Automata II: Notes comes from a cell value of the Heat Cellular Automata in time.
Cellular Automata III: Variation of the Heat Cellular Automata Generator.
Cellular Automata IV: Variation of the Heat Cellular Automata Generator in time.
Harmonic Oscillator: Simple Harmonic Oscillator
Lyapunov Fractal: Generate notes from the Lyapunov Fractal iteration
Markov Chains: Simple tone generator using Markov Chains
Normalized AI Inverse Pentatonic: Normalized AI Generator over the pentatonic scale with tonal inversion
Normalized AI Inverse Scale: Normalized AI Generator over the selected tones with tonal inversion
Normalized AI Inverse: Normalized AI Generator over white notes with tonal inversion
Pattern II: Multi tonal repetitive pattern
Pattern: Simple repetitive tonal pattern
Pentatonic Markov Chain: Markov Chain generator over the pentatonic scale
Pentatonic Walk I: Random Walk over the pentatonic scale
Pentatonic Walk II: Weighted Random Walk over the pentatonic scale
Pentatonic Walk III: Variation of the Weighted Random Walk over the pentatonic scale
Random Walk II: Random Walk over selected tones
Random Walk: Simple Random Walk generator
Random: Creates a random sequence of notes
Sine Wave: Notes are created from a sinusoidal curve
Symmetric Random Walk: Uses a symmetrical version of the Random Walk algorithm
Tone Walk I: Random walk using Tonnetz
Tone Walk II: Weighted Random Walk using Tonnetz
Tone Walk III: Variation of the Random Walk using Tonnetz

The Musical Transformations are a set of rules applied to the current Base Pattern, that modify the notes in both tones and positions.
The Transformations can also reverse in time the note structure, also can invert the tones of the notes.

First Half 1 Octave Down: The second half contains the notes of the first half lowered one octave.
First Half 1 Octave Up: The second half contains the notes of the first half raised one octave.
First Half Mirrored, 1 Octave Down: The second half contains the notes of the first half lowered one octave but reversed in time.
First Half Mirrored, 1 Octave Up: The second half contains the notes of the first half raised one octave but reversed in time.
First Half Mirrored, 1 Octave Up: The second half contains the notes of the first half raised one octave but reversed in time.
Mirror First Half: The first half of the Base Pattern is mirrored in the second half
Mirror Second Half: The second half of the Base Pattern is mirrored on the first half
No Transformation: No Transformation is applied to the current Base Pattern
One Octave Down, Period 16: The tone of the note is lowered one octave every 16 notes during the next 16 notes.
One Octave Down, Period 32: The tone of the note is lowered one octave every 32 notes during the next 32 notes.
One Octave Up, Period 16: The tone of the note is raised one octave every 16 notes during the next 16 notes.
One Octave Up, Period 32: The tone of the note is raised one octave every 32 notes during the next 32 notes.
Period One Round Wave: The tone of the note is affected by the amplitude of the round wave.
Period One Sine Wave: The tone of the note is affected by the amplitude of the sinusoidal wave.
Period One Triangular Wave: The tone of the note is affected by the amplitude of the triangular wave.
Period Two Round Wave: The tone of the note is affected by the amplitude of the round wave with double frequency.
Period Two Sine Wave: The tone of the note is affected by the amplitude of the sinusoidal wave with double frequency.
Period Two Triangular Wave: The tone of the note is affected by the amplitude of the triangular wave with double frequency.
Second Half Mirrored, 1 Octave Down: The first half contains the notes of the second half lowered one octave but reversed in time.
Second Half Mirrored, 1 Octave Up: The first half contains the notes of the second half raised one octave but reversed in time.
Time Reversed: The whole base pattern is reversed in time.

------------------------- Markov chain ---------------------------------
first-order Markov chain.
Current next next next
Note    A    B    C
A       20%  50%  30%
B       35%  25%  40%
C       70%  14%  16%

second-order Markov chain. current state and also the previous state
Current next next next
Notes   A    B    C
A A     15%  55%  30%
A B     20%  45%  35%
A C     60%  30%  10%
B A     35%  25%  40%
B B     49%  48%  3%
B C     60%  20%  20%
C A     5%   75%  20%
C B     0%   90%  10%
C C     70%  14%  16%

*/

// All the neb variables.
NVariable BACKCOL;
NVariable KPITCH;
NVariable MOD1;
NVariable KNOTE;

// All the tracks.
NTrack KEYS;
NTrack SYNTH;
NTrack BASS;

// Neb script stuff.
int[] _chordNotes;
int[] _scaleNotes;
int[] _notesPlaying = new int[128];


public override void setupNeb()
{
    // const int WHEN1 = 8;

    // All the neb variables.
    BACKCOL = createVariable("color", 200, 0, 255, On_BACKCOL);
    KPITCH = createVariable("pitch", 8192, 0, 16383); // center is 8192
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KNOTE = createVariable("note", 60, -127, 127, On_KNOTE);

    // All the tracks.
    KEYS = createTrack("keys", 1, 5, 0, 0);
    SYNTH = createTrack("synth", 3, 0);
    BASS = createTrack("drums", 10, 4, 0, 0);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // devices
    createControllerIn(KEYS, 4, BACKCOL);
    createControllerIn(KEYS, PITCH_CTL, KPITCH);
    createControllerIn(KEYS, NOTE_CTL, KNOTE);

    createLever(BACKCOL);
    createLever(KPITCH);
    createLever(MOD1);

    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        sendPatch(SYNTH, Pad3Polysynth);
        sendPatch(BASS, AcousticBass);
    }
}

public override void setup()
{
    colorMode(HSB, 360, 100, 100);
    noStroke(); // draw no lines
    frameRate(10);

    BACKCOL.Value = 100;

    //noFill();
    //stroke(0, 128);
}

public override void step()
{
    //Tick sort of corresponds to a beat (or whatever you mean it to be) and Tock is 1/96 of a Tick.

    // if(tick == 5)
    // {
    //     speed = 50;
    //     volume = 50;
    // }

    if(tock == 0)
    {
        // algoDynamic();
    }
}

public override void keyPressed()
{
    print("keyPressed:", key);
}

public void On_BACKCOL()
{
    print(BACKCOL.Name, "changed to", BACKCOL.Value);
}

public void On_MOD1()
{
    print(MOD1.Name, "changed to", MOD1.Value);

    // Send a control change.
    sendController(KEYS, 1, MOD1.Value);
}

public void On_KNOTE()
{
    print("KNOTE = ", KNOTE.Value);
}

public override void draw()
{
    //print("draw");
    background(BACKCOL.Value, 100, 200);

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

void drawTarget(float xloc, float yloc, int size, int num)
{
    int grayvalues = 255 / num;
    float steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, (_c * 1) % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendNote(SYNTH, sn, 90, 0.48);
}
