
// Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.

// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable KEYS_NOTE;
NVariable CTL2;
NVariable CTL3;

// All the tracks.
NTrack KEYS;
NTrack SYNTH;
NTrack BASS;
NTrack DRUMS;

// Neb script stuff.
int[] _chordNotes;
int[] _scaleNotes;
//int[] _notesPlaying = new int[128];
int _noteNum = 0;

// Processing stuff.
int _segmentCount = 36; // 360;
int _radius = 300;


public override void setupNeb()
{
    // All the neb variables.
    CTL2 = createVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = createVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = createVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KEYS_NOTE = createVariable("note", 60, -127, 127, On_KEYS_NOTE); // neg number for note off encoding TODOX?

    // All the tracks.
    KEYS = createTrack("keys", 1, 5, 0, 0);
    BASS = createTrack("bass", 2, 4, 0, 0);
    SYNTH = createTrack("synth", 3, 0);
    DRUMS = createTrack("drums", 10, 4, 0, 0);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // controller points
    createControllerIn(KEYS, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
    createControllerIn(KEYS, 3, CTL3); // another controller
    createControllerIn(KEYS, 4, BACK_COLOR); // change ui color
    createControllerIn(KEYS, NoteControl, KEYS_NOTE);  // make some funny notes

    // levers
    createLever(BACK_COLOR);
    createLever(MOD1);

    // Get some stock chords and scales
    _chordNotes = getNotes("C4.o7");
    _scaleNotes = getScaleNotes("Algerian", "A3");

    // NSequence DRUMS_VERSE;
    // DRUMS_VERSE.Add(5.10, RideCymbal1,      DRUM_DEF_VOL);
    // DRUMS_VERSE.Add(5.60, HiMidTom,         DRUM_DEF_VOL);
    // DRUMS_VERSE.Add(6.00, AcousticBassDrum, DRUM_DEF_VOL);
    // DRUMS_VERSE.Add(7.00, CrashCymbal2,     DRUM_DEF_VOL);

    // NSequence DRUMS_SIMPLE;
    // // Using patterns. Each hit is 1/16 note - fixed resolution and volume for now.
    // DRUMS_SIMPLE = createSequence(8);
    // DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 90);
    // DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare,    80);

    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        sendPatch(SYNTH, Pad3Polysynth);
        sendPatch(BASS, AcousticBass);
    }
}

public override void step()
{
    // Tick sort of corresponds to a beat (or whatever you mean it to be) and Tock is 1/96 of a Tick.

    bool doTick = false;

    switch(tock)
    {
        case 0:
            doTick = true;
            break;

        case 8:
        case 16:
        case 24:
        //case 32:
            int sn = _scaleNotes[_noteNum++ % _scaleNotes.Count()];
            sendNote(SYNTH, sn + tick, 90, 0.28);
            break;

        default:
            break;
    }

    if(doTick)
    {
        // keys
        switch(tick % 16)
        {
            case 0:
            case 4:
            case 8:
            case 12:
                //playSequence(KEYS, SEQ1);
                foreach(int n in _chordNotes)
                {
                    sendNote(KEYS, n, 90, 1.0);
                }
                break;
        }

        // bass
        switch(tick % 16)
        {
            case 0:
            case 7:
            case 8:
                sendNote(BASS, 50, 90, 2.0);
                break;
        }
    }
}

////////////////////////////// ui //////////////////////////

public override void setup()
{
    colorMode(HSB, 360, 100, 100);
    noStroke(); // draw no lines
    frameRate(2);

    BACK_COLOR.Value = 100;
}

public override void keyPressed()
{
    print("keyPressed:", key);
}

public void On_BACK_COLOR()
{
    print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}

public void On_CTL2()
{
    // 0 -> 127 in
    int newval = (int)map(CTL2.Value, 0, 127, 0, 16383);
    //print("On_CTL2:", newval);
    sendController(SYNTH, PitchControl, newval);
}

public void On_CTL3()
{
    sendNote(KEYS, 50 + CTL3.Value % 20, 90, 2.0);
}

public void On_MOD1()
{
    print(MOD1.Name, "changed to", MOD1.Value);

    // Send a control change.
    sendController(KEYS, 1, MOD1.Value);
}

public void On_KEYS_NOTE()
{
    print("KEYS_NOTE", "=", KEYS_NOTE.Value);

    // Test for on or off. TODOX
    if(KEYS_NOTE.Value > 0)
    {
        sendNote(SYNTH, KEYS_NOTE.Value, 110, 0.0); // noteon
        //sendNote(SYNTH, KEYS_NOTE.Value, 90, 2.0); // fixed duration
    }
    else
    {
        sendNote(SYNTH, -KEYS_NOTE.Value, 0, 0.0); // noteoff
    }
}

public override void draw()
{
    // drawFan();
    drawTargets();
}

void drawFan()
{
    noStroke();
    colorMode(HSB, 360, width, height);
    background(160); // gray

    float angleStep = 360 / _segmentCount;

    for (float angle = 0; angle <= 360; angle += angleStep)
    {
        fill(angle, mouseX % width, mouseY % height);

        beginShape();  // (TRIANGLE_FAN);
        vertex(width / 2, height / 2); // center

        float vx = width / 2 + cos(radians(angle)) * _radius;
        float vy = height / 2 + sin(radians(angle)) * _radius;
        vertex(vx, vy);
        
        vx -= 10;
        vy -= 10;
        vertex(vx, vy);
    
        endShape(CLOSE);
    }
}

void drawTargets()
{
    //print("draw");
    background(BACK_COLOR.Value, 100, 200);

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

void drawTarget(float xloc, float yloc, int size, int num)
{
    int grayvalues = 255 / num;
    float steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, 0 % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendNote(SYNTH, sn, 90, 0.48);
}


/*
--------------------------------------------------------------------
Types of contrapuntal motion

In parallel motion, two voices move in the same direction by the same generic interval. For example, the following two voices both move up by a step. Note also that both dyads form the same generic interval (sixth). This will always be true when two voices move in parallel motion.

In similar motion, also called direct motion, two voices move in the same direction, but by different intervals. For example, the following two voices both move down, but the upper voice moves by step while the lower voice moves by leap. Note also that the two dyads are different generic intervals. This will always be the case with similar or direct motion.

In contrary motion, two voices move in opposite directionsâ€”one up, the other down.

In oblique motion, one voice is stationary, while the other voice moves (in either direction). The stationary tone may or may not be rearticulated.

--------------------------------------------------------------------
Generative Music becomes Reflective Music when your text can be used as a seed for how it starts.
http://spheric-lounge-live-ambient-music.blogspot.com/

The random item stream pattern type uses the optional keyword :weight to alter the probability of an event being selected in relation to the other events in the item stream.
>>> need this, for scale note selections.

The graph item stream pattern type creates an item stream of user-specified rules for traversing a series of nodes called a graph.
>>> my loops - rules to change/transition.

Sonification uses data that is typically not musical and involves remapping this to musical parameters to create a composition.

---------------------------------------------------------------------
How Phase Music Works
Phasing by playing e.g. six loops with different durations - sync/phase.

Random note/Octave Shifts, Instrumentation, etc...

And now we come to the real technical trick that underlies "It's Gonna Rain": What we are hearing are two identical tape loops playing at the same time. There's one in the left ear and one in the right. But one of those loops is running ever so slightly faster than the other.

The difference is so small you don't even notice it at first, but after a while it amounts to a phase shift between the two loops that keeps growing bigger and bigger as time goes by. First it sounds like there's an echo. Then the echo transforms into a repeating effect, and then it builds into a series of strange combinations of sounds as different parts of the sample overlap with others. At the halfway point the loops start to approach each other again, and we go back through repetition and echo to unison.

--------------------------------------------------------------------
http://www.auralfractals.net/about/

The Generators are a series of algorithms used for creating musical compositions. They generate the base pattern seed from diverse 
procedural methods, such as fractals (The Lyapunov Generators, Random Walks, etc), Cellular Automatas (Heat CA, Harmonic Oscillators), or musical rules (Tone Walks).

The generators can be accessed from the Base Pattern Editor.

AI Inverse Pentatonic: AI Generator over the pentatonic scale with tonal inversion
AI Inverse Scale:: AI Generator over the selected tones with tonal inversion
AI Inverse: AI Generator over white notes with tonal inversion
AI Pentatonic: Artificial Intelligence Generator over the pentatonic scale
AI Scale: Artificial Intelligence Generator over the selected tones
AI White Notes: Artificial Intelligence Generator over white notes
Cellular Automata I: Notes comes from the cell values of the Heat Cellular Automata.
Cellular Automata II: Notes comes from a cell value of the Heat Cellular Automata in time.
Cellular Automata III: Variation of the Heat Cellular Automata Generator.
Cellular Automata IV: Variation of the Heat Cellular Automata Generator in time.
Harmonic Oscillator: Simple Harmonic Oscillator
Lyapunov Fractal: Generate notes from the Lyapunov Fractal iteration
Markov Chains: Simple tone generator using Markov Chains
Normalized AI Inverse Pentatonic: Normalized AI Generator over the pentatonic scale with tonal inversion
Normalized AI Inverse Scale: Normalized AI Generator over the selected tones with tonal inversion
Normalized AI Inverse: Normalized AI Generator over white notes with tonal inversion
Pattern II: Multi tonal repetitive pattern
Pattern: Simple repetitive tonal pattern
Pentatonic Markov Chain: Markov Chain generator over the pentatonic scale
Pentatonic Walk I: Random Walk over the pentatonic scale
Pentatonic Walk II: Weighted Random Walk over the pentatonic scale
Pentatonic Walk III: Variation of the Weighted Random Walk over the pentatonic scale
Random Walk II: Random Walk over selected tones
Random Walk: Simple Random Walk generator
Random: Creates a random sequence of notes
Sine Wave: Notes are created from a sinusoidal curve
Symmetric Random Walk: Uses a symmetrical version of the Random Walk algorithm
Tone Walk I: Random walk using Tonnetz
Tone Walk II: Weighted Random Walk using Tonnetz
Tone Walk III: Variation of the Random Walk using Tonnetz

The Musical Transformations are a set of rules applied to the current Base Pattern, that modify the notes in both tones and positions.
The Transformations can also reverse in time the note structure, also can invert the tones of the notes.

First Half 1 Octave Down: The second half contains the notes of the first half lowered one octave.
First Half 1 Octave Up: The second half contains the notes of the first half raised one octave.
First Half Mirrored, 1 Octave Down: The second half contains the notes of the first half lowered one octave but reversed in time.
First Half Mirrored, 1 Octave Up: The second half contains the notes of the first half raised one octave but reversed in time.
First Half Mirrored, 1 Octave Up: The second half contains the notes of the first half raised one octave but reversed in time.
Mirror First Half: The first half of the Base Pattern is mirrored in the second half
Mirror Second Half: The second half of the Base Pattern is mirrored on the first half
No Transformation: No Transformation is applied to the current Base Pattern
One Octave Down, Period 16: The tone of the note is lowered one octave every 16 notes during the next 16 notes.
One Octave Down, Period 32: The tone of the note is lowered one octave every 32 notes during the next 32 notes.
One Octave Up, Period 16: The tone of the note is raised one octave every 16 notes during the next 16 notes.
One Octave Up, Period 32: The tone of the note is raised one octave every 32 notes during the next 32 notes.
Period One Round Wave: The tone of the note is affected by the amplitude of the round wave.
Period One Sine Wave: The tone of the note is affected by the amplitude of the sinusoidal wave.
Period One Triangular Wave: The tone of the note is affected by the amplitude of the triangular wave.
Period Two Round Wave: The tone of the note is affected by the amplitude of the round wave with double frequency.
Period Two Sine Wave: The tone of the note is affected by the amplitude of the sinusoidal wave with double frequency.
Period Two Triangular Wave: The tone of the note is affected by the amplitude of the triangular wave with double frequency.
Second Half Mirrored, 1 Octave Down: The first half contains the notes of the second half lowered one octave but reversed in time.
Second Half Mirrored, 1 Octave Up: The first half contains the notes of the second half raised one octave but reversed in time.
Time Reversed: The whole base pattern is reversed in time.

------------------------- Markov chain ---------------------------------
first-order Markov chain.
Current next next next
Note    A    B    C
A       20%  50%  30%
B       35%  25%  40%
C       70%  14%  16%

second-order Markov chain. current state and also the previous state
Current next next next
Notes   A    B    C
A A     15%  55%  30%
A B     20%  45%  35%
A C     60%  30%  10%
B A     35%  25%  40%
B B     49%  48%  3%
B C     60%  20%  20%
C A     5%   75%  20%
C B     0%   90%  10%
C C     70%  14%  16%

*/
