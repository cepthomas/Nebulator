
///// Tester for development features.

// My akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.

// Support microtonal notes with Pitch changes.
// Modulate to a specified key. Requires specifying current key too.


// Import other stuff.
#load "scale.neb";

// All the neb variables.
NVariable COL1;
NVariable PITCH;
NVariable MOD1;
NVariable NOTECTL;

// All the tracks.
NTrack KEYS;
NTrack SYNTH;
NTrack DRUMS;

// All the sequences
NSequence SEQ1;
NSequence DRUMS_SIMPLE;

// Sections.
NSection PART1;

// Neb script stuff.
int[] _chordNotes;
int[] _scaleNotes;
int[] _notesPlaying = new int[128];
Scale _scale;

float _ypos = 0;
int _c = 0;
int tileCountX = 10;
int tileCountY = 10;
int tileWidth = 0;
int tileHeight = 0;

public override void setupNeb()
{
    const int WHEN1 = 8;

    // All the neb variables.
    COL1 = createVariable("color", 200);
    PITCH = createVariable("pitch", 8192); // center is 8192
    MOD1 = createVariable("mod", 127);
    NOTECTL = createVariable("note", 127);

    // Handle a change.
    COL1.Changed += On_COL1;
    MOD1.Changed += On_MOD1;
    NOTECTL.Changed += On_NOTECTL;

    // All the tracks.
    KEYS = createTrack("keys", 1, 5, 0, 0);
    SYNTH = createTrack("synth", 3, 0);
    DRUMS = createTrack("drums", 10, 4, 0, 0);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // devices
    createControllerIn(KEYS, 4, COL1);
    createPitchIn(KEYS, PITCH);
    createNoteIn(KEYS, NOTECTL);
    createLever(0, 255, COL1);
    createLever(0, 16383, PITCH); // max range
    createLever(0, 255, MOD1);

    // Create sequences, add notes/chords/funcs.
    SEQ1 = createSequence(8);
    SEQ1.Add(00.00, "G3", 90, 0.60);
    SEQ1.Add(01.00, algoDynamic, 90);
    SEQ1.Add(02.00, "A3.m7", 90, 0.60);
    SEQ1.Add(03.00, 66, 90, 0.60);
    SEQ1.Add(03.48, CrashCymbal1, 90, 0.60);

    DRUMS_SIMPLE = createSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 90);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare, 80);
    DRUMS_SIMPLE.Add("------xx------xx------xx------xx", ClosedHiHat, 100);

    // section
    NSection PART1 = ceateSection("section", WHEN1, 0);
    PART1.Add(KEYS, SEQ1, SEQ1);
    PART1.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);

    // Get some stock chords and scales
    _chordNotes = getNotes("C4.o7");
    _scaleNotes = getScaleNotes("Algerian", "A3");

    _scale = new Scale("Algerian", "C4", 0, 0);
    // 1 2 b3 #4 5 b6 7
    _scale.setWeight(0, 50);
    _scale.setWeight(4, 50);
    _scale.setWeight(2, 30);

    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        //sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Pad3Polysynth);
    }
}

public override void setup()
{
    colorMode(HSB, 360, 100, 100);
    noStroke();
    frameRate(1);

    COL1.Value = 999;

    tileWidth = width / tileCountX;
    tileHeight = height / tileCountY;
    noFill();
    stroke(0, 128);
}

public override void step()
{
    // if(tick == 5)
    // {
    //     speed = 50;
    //     volume = 50;
    // }

    if(tock == 0)
    {
        algoDynamic();
        //algoSequences();
    }
}

void algoDynamic()
{
    int n = _scale.randomNote();
    sendNote(SYNTH, n, 90, 0.48);
}

void algoSequences()
{
    // if(tick % 9 == 0)
    // {
    //     playSequence(KEYS, SEQ1);
    // }

    // if(tick % 13 == 0)
    // {
    //     playSequence(KEYS, SEQ2);
    // }
}

public override void keyPressed()
{
    print("keyPressed:", key);
}

public void On_COL1()
{
    print("COL1 changed to", COL1);
    //modulate(KEYS, COL1);
}

public void On_MOD1()
{
    print("MOD1 changed to", MOD1);

    // Send a control change.
    // public void sendController(NTrack track, int ctlnum, int val)
    sendController(KEYS, 1, MOD1.Value);
}

public void On_NOTECTL()
{
    print("NOTECTL = ", NOTECTL);
}

public override void draw()
{
    //print("draw");
    background(COL1.Value, 100, 200);

    // Recursive:
    // strokeWeight(1);
    // drawRecursive(0, 0, width / 2, 1);
    // return;

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    // if (mouseIsPressed)
    // {
    //     //print("mouse is pressed");
    //     fill(random(255), random(255), random(255));
    //     strokeWeight(2);
    //     stroke(0, 100);
    //     ellipse(mouseX, mouseY, 80, 80);
    // }
}

void drawTarget(float xloc, float yloc, int size, int num)
{
    int grayvalues = 255 / num;
    float steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, (_c * 1) % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
        
        //psychedelic:
        //_c++;
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendNote(SYNTH, sn, 90, 0.48);
}

// Recursive rendering.
void drawRecursive(float x, float y, float squareSize, float minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
