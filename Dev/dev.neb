
///// Tester for development features.

// My akai kbd midi: Pad1-8 = 44-51, knob1-8 = ctlr1-8


include ..\Examples\utils.neb
include scale.neb


////////// Constants //////////
constant WHEN1         32
constant KEYS_DEF_VOL 100
constant DRUM_DEF_VOL 100


////////// Variables //////////
variable COL1   200 // change color
variable MODN     0 // modulate notes
variable PITCH 8192 // center is 8192

////////// Chords and scales //////////
notes CHORD1   1 2 3
notes CHORD2   1 4 6 b13
notes MY_SCALE 1 3 4 b7

////////// Realtime Controllers //////////
midictlin  MI1 1 4     MODN
midictlout MO1 1 Pitch PITCH

////////// Levers //////////
lever L1   0  255   COL1
lever L2   0  16383 PITCH // max range
lever L3 -10  10    MODN

////////// Tracks //////////
track KEYS   1 5 0 0
track BASS   2 2 0 0
track SYNTH  3 0
track DRUMS 10 4 0 0

////////// Sections //////////
section PART1 0 WHEN1 // section name start length
KEYS    SEQ1           ALGO1       SEQ1          SEQ2  // trackname sequence sequence ...
DRUMS   DRUMS_SIMPLE   DRUMS_HH    DRUMS_SIMPLE  DRUMS_HH

section PART2 WHEN1 60
KEYS    SEQ1      SEQ2 
DRUMS   DRUMS_HH  DRUMS_HH   

////////// Sequences //////////

sequence SEQ1 8
00.00  G3        90  0.60
01.00  A3.m7     90  0.60
02.00  Bb3       90  0.60
03.00  C4.CHORD2 90  0.60

sequence SEQ2 8
00.00  C4  90  0.60
01.00  D4  90  0.60
02.00  E4  90  0.60
03.00  F4  90  0.60

sequence ALGO1 8
00.00  algoSequences()  90


// Sequences using patterns. Each hit is 1/16 note - fixed res for now.
sequence  DRUMS_SIMPLE  8 // 32 x 1/16 = 8 x 1/4
x-------x-------x-------x-------  AcousticBassDrum  90
----x-------x-x-----x-------x-x-  AcousticSnare     80

sequence  DRUMS_HH  8
------xx------xx------xx------xx  ClosedHiHat  100


///// Functions /////


// Index is note number, value is which tick to stop it.
int[] _notesPlaying = new int[128];

// Test scale.
Scale _scale;

public override void setup()
{
    colorMode(HSB, 360, 100, 100);
    noStroke();
    frameRate(1);

    _scale = new Scale("Algerian", "C4", 1, 1);
    // 1 2 b3 #4 5 b6 7
    _scale.SetWeight(0, 50);
    _scale.SetWeight(4, 40);
    _scale.SetWeight(2, 30);

    // // Test stuff.
    // int[] notes = getNotes("C4");
    // int[] scaleNotes = getScaleNotes("Algerian", "C4");

    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Pad3Polysynth);
    }
}

public override void step()
{
    // if(tick == 5)
    // {
    //     speed = 50;
    //     volume = 50;
    // }

    if(tock == 0)
    {
        algoDynamic();
        //algoSequences();
        //algoRandom();
    }
}

void algoDynamic()
{
    int which = _scale.RandomNote();

    if(_notesPlaying[which] == 0) // don't play if already playing
    {
        //print("algoDynamic:", which);
        int dur = random(1, 8);
        _notesPlaying[which] = tick + dur;
        sendMidiNote(SYNTH, which, random(80, 100), dur);
    }

    // Remove any scheduled to stop now.
    for(int i = 0;i < _notesPlaying.Length;i++)
    {
        if(_notesPlaying[i] != 0 && _notesPlaying[i] == tick)
        {
            //sendMidiNote(SYNTH, _notesPlaying[i], 0, 0.00);
            _notesPlaying[i] = 0;
        }
    }
}

void algoSequences()
{
    // if(tick % 9 == 0)
    // {
    //     playSequence(KEYS, SEQ1);
    // }

    // if(tick % 13 == 0)
    // {
    //     playSequence(KEYS, SEQ2);
    // }
}

public void On_MODN()
{
    //print("MODN changed to", MODN);
    modulate(KEYS, MODN);
}

public override void draw()
{
    //print("draw");
    background(COL1, 100, 200);

    // Recursive:
    // drawRecursive(0, 0, width / 2, 1); // This uses a whole core with GDI.
    // noLoop(); // run once only
    // return;

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendMidiNote(SYNTH, sn, 90, 0.48);
}


/////// Just a thing from Functions example.
float _ypos = 0;
int _c = 0;

void drawTarget(float xloc, float yloc, int size, int num)
{
    int grayvalues = 255 / num;
    float steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, (_c * 1) % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
        
        //psychedelic:
        _c++;
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}


// Recursive rendering. CPU intensive.
void drawRecursive(float x, float y, float squareSize, float minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
