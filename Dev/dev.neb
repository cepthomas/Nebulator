
///// Tester for development features.

// My akai kbd midi: Pad1-8 = 44-51, knob1-8 = ctlr1-8


// Import other stuff.
#load "scale.neb";

// All the neb variables.
NVariable COL1;
NVariable PITCH;

// All the tracks.
NTrack KEYS;
NTrack SYNTH;
NTrack DRUMS;

// All the sequences
NSequence SEQ1;
NSequence DRUMS_SIMPLE;

// Sections.
NSection PART1;

// Neb script stuff.
int[] chordNotes;
int[] scaleNotes;
int[] _notesPlaying = new int[128];
Scale _scale;

public override void setupNeb()
{
    const int WHEN1 = 8;

    // All the neb variables.
    COL1 = variable("color", 200);
    PITCH = variable("pitch", 8192); // center is 8192

    // Handle a change.
    COL1.Changed += On_COL1;

    // All the tracks.
    KEYS = track("keys", 1, 5, 0, 0);
    SYNTH = track("synth", 3, 0);
    DRUMS = track("drums", 10, 4, 0, 0);

    // create set of notes (chord)
    notes("MY_CHORD", "1 4 6 b13");
    notes("MY_SCALE", "1 3 4 b7");

    // devices
    midiIn(1, 4, COL1);
    midiOut(1, CTRL_PITCH, PITCH);
    lever(0, 255, COL1);
    lever(0, 16383, PITCH); // max range

    // Create sequences, add notes/chords/funcs.
    SEQ1 = sequence(8);
    SEQ1.Add(00.00, "G3", 90, 0.60);
    SEQ1.Add(01.00, algoDynamic, 90);
    SEQ1.Add(02.00, "A3.m7", 90, 0.60);
    SEQ1.Add(03.00, 66, 90, 0.60);
    SEQ1.Add(03.48, CrashCymbal1, 90, 0.60);

    DRUMS_SIMPLE = sequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 90);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare, 80);
    // sequence  DRUMS_HH  8
    // ------xx------xx------xx------xx  ClosedHiHat  100

    // section
    NSection PART1 = section("section", WHEN1, 0);
    PART1.Add(KEYS, SEQ1, SEQ1);
    PART1.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);

    // Get some stock chords and scales
    chordNotes = getNotes("C4.o7");
    scaleNotes = getScaleNotes("Algerian", "A3");

    _scale = new Scale("Algerian", "C4", 0, 0);
    // 1 2 b3 #4 5 b6 7
    _scale.setWeight(0, 50);
    _scale.setWeight(4, 50);
    _scale.setWeight(2, 30);

    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        //sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Pad3Polysynth);
    }
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



float _ypos = 0;
int _c = 0;
int tileCountX = 10;
int tileCountY = 10;
int tileWidth = 0;
int tileHeight = 0;

public override void setup()
{
    colorMode(HSB, 360, 100, 100);
    noStroke();
    frameRate(1);

    COL1.Value = 999;  // COL1 = 999; TODO Prefer this to .Value but would be difficult or impossible.

    tileWidth = width / tileCountX;
    tileHeight = height / tileCountY;
    noFill();
    stroke(0, 128);
}

public override void step()
{
    // if(tick == 5)
    // {
    //     speed = 50;
    //     volume = 50;
    // }

    if(tock == 0)
    {
        algoDynamic();
        //algoSequences();
    }
}

void algoDynamic()
{
    int n = _scale.randomNote();
    sendMidiNote(SYNTH, n, 90, 0.48);
}

void algoSequences()
{
    // if(tick % 9 == 0)
    // {
    //     playSequence(KEYS, SEQ1);
    // }

    // if(tick % 13 == 0)
    // {
    //     playSequence(KEYS, SEQ2);
    // }
}

public override void keyPressed()
{
    print("keyPressed:", key);
}

public void On_COL1()
{
    print("COL1 changed to", COL1);
    //modulate(KEYS, COL1);
}

public override void draw()
{
    //print("draw");
    background(COL1.Value, 100, 200);

    // Recursive:
    // strokeWeight(1);
    // drawRecursive(0, 0, width / 2, 1);
    // return;

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    // if (mouseIsPressed)
    // {
    //     //print("mouse is pressed");
    //     fill(random(255), random(255), random(255));
    //     strokeWeight(2);
    //     stroke(0, 100);
    //     ellipse(mouseX, mouseY, 80, 80);
    // }
}

void drawTarget(float xloc, float yloc, int size, int num)
{
    int grayvalues = 255 / num;
    float steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, (_c * 1) % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
        
        //psychedelic:
        //_c++;
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendMidiNote(SYNTH, sn, 90, 0.48);
}

// Recursive rendering. CPU intensive.
void drawRecursive(float x, float y, float squareSize, float minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
