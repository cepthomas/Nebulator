
TODO Stuff to implement (probably) in neb files. Make some "library" files.


-------------------------

// gibber.js example:

// music
b = EDrums('x*o*x*o-')
b.amp = .75

c = FM('bass')
  .note.seq( [0,0,0,7,14,13].rnd(), [1/8,1/16].rnd(1/16,2) )

d = Synth( 'rhodes', {amp:.35} )
  .chord.seq( Rndi(0,6,3), 1 )
  .fx.add( Delay() )

Gibber.scale.root.seq( ['c4','ab3','bb3'], [4,2,2] )
Gibber.scale.mode.seq( ['Minor','Mixolydian'], [6,2] )

// analysis
fftSize = 32
fft = FFT( fftSize )

// visuals
a = Canvas()

a.draw = function() {
  a.clear()
  var numBars = fftSize / 2,
      barHeight = ( a.height - 1 ) / numBars,
      barColor = null, 
      value = null

  for( var i = 0; i < numBars; i++ ) {
    barColor = Color({ h:( i / numBars ) * 255, s:255, v:255 })

    // read FFT value, which ranges from 0-255, and scale it.
    value = ( fft[ i ] / 255 ) * a.width

    a.rectangle( 0, barHeight * i, value, barHeight )
    a.fill( barColor.rgbString() ) 

  }
}

-------------------------
Exquisite Score is a web application which allows users to collaborate on short musical compositions using the paradigm of the parlor game Exquisite Corpse. Through a MIDI-sequencer interface, composers each contribute a section to a piece of music, only seeing a brief fragment immediately preceding their section. Exquisite Score went through many iterations and was tested by several students and musicians. Several short pieces were produced, some of which are included and analyzed here. Exquisite Score succeeds in providing a new way to create collaborative musical compositions that celebrate the novel and creative.

-------------------------
Modulate to a specified key. Requires specifying current key too.


-------------------------
Generators - something like this:
---------------
AI Inverse Pentatonic: AI Generator over the pentatonic scale with tonal inversion
AI Inverse Scale:: AI Generator over the selected tones with tonal inversion
AI Inverse: AI Generator over white notes with tonal inversion
AI Pentatonic: Artificial Intelligence Generator over the pentatonic scale
AI Scale: Artificial Intelligence Generator over the selected tones
AI White Notes: Artificial Intelligence Generator over white notes
Cellular Automata I: Notes comes from the cell values of the Heat Cellular Automata.
Cellular Automata II: Notes comes from a cell value of the Heat Cellular Automata in time.
Cellular Automata III: Variation of the Heat Cellular Automata Generator.
Cellular Automata IV: Variation of the Heat Cellular Automata Generator in time.
Harmonic Oscillator: Simple Harmonic Oscillator
Lyapunov Fractal: Generate notes from the Lyapunov Fractal iteration
Markov Chains: Simple tone generator using Markov Chains
Normalized AI Inverse Pentatonic: Normalized AI Generator over the pentatonic scale with tonal inversion
Normalized AI Inverse Scale: Normalized AI Generator over the selected tones with tonal inversion
Normalized AI Inverse: Normalized AI Generator over white notes with tonal inversion
Pattern II: Multi tonal repetitive pattern
Pattern: Simple repetitive tonal pattern
Pentatonic Markov Chain: Markov Chain generator over the pentatonic scale
Pentatonic Walk I: Random Walk over the pentatonic scale
Pentatonic Walk II: Weighted Random Walk over the pentatonic scale
Pentatonic Walk III: Variation of the Weighted Random Walk over the pentatonic scale
Random Walk II: Random Walk over selected tones
Random Walk: Simple Random Walk generator
Random: Creates a random sequence of notes
Sine Wave: Notes are created from a sinusoidal curve
Symmetric Random Walk: Uses a symmetrical version of the Random Walk algorithm
Tone Walk I: Random walk using Tonnetz
Tone Walk II: Weighted Random Walk using Tonnetz
Tone Walk III: Variation of the Random Walk using Tonnetz

Transformations
-------------------
First Half 1 Octave Down: The second half contains the notes of the first half lowered one octave.
First Half 1 Octave Up: The second half contains the notes of the first half raised one octave.
First Half Mirrored, 1 Octave Down: The second half contains the notes of the first half lowered one octave but reversed in time.
First Half Mirrored, 1 Octave Up: The second half contains the notes of the first half raised one octave but reversed in time.
First Half Mirrored, 1 Octave Up: The second half contains the notes of the first half raised one octave but reversed in time.
Mirror First Half: The first half of the Base Pattern is mirrored in the second half
Mirror Second Half: The second half of the Base Pattern is mirrored on the first half
No Transformation: No Transformation is applied to the current Base Pattern
One Octave Down, Period 16: The tone of the note is lowered one octave every 16 notes during the next 16 notes.
One Octave Down, Period 32: The tone of the note is lowered one octave every 32 notes during the next 32 notes.
One Octave Up, Period 16: The tone of the note is raised one octave every 16 notes during the next 16 notes.
One Octave Up, Period 32: The tone of the note is raised one octave every 32 notes during the next 32 notes.
Period One Round Wave: The tone of the note is affected by the amplitude of the round wave.
Period One Sine Wave: The tone of the note is affected by the amplitude of the sinusoidal wave.
Period One Triangular Wave: The tone of the note is affected by the amplitude of the triangular wave.
Period Two Round Wave: The tone of the note is affected by the amplitude of the round wave with double frequency.
Period Two Sine Wave: The tone of the note is affected by the amplitude of the sinusoidal wave with double frequency.
Period Two Triangular Wave: The tone of the note is affected by the amplitude of the triangular wave with double frequency.
Second Half Mirrored, 1 Octave Down: The first half contains the notes of the second half lowered one octave but reversed in time.
Second Half Mirrored, 1 Octave Up: The first half contains the notes of the second half raised one octave but reversed in time.
Time Reversed: The whole base pattern is reversed in time.


-------------------------
Pärt designed strict rules to control how the harmonic voices move with the melodic lines in his music

In Tintinnabuli there are two dominant voices. The first voice or the "tintinnabular voice" sings or performs an arpeggio or the tonic triad. The second voice moves diatonically in a stepwise motion. One of the clearest and most famous examples of this is "Spiegel im Spiegel," seen above in the Gravity trailer.

Für Alina (1976), the work in which he discovered the triad series, which he made his “simple, little guiding rule.” Describing the sound of the triad as like that of pealing bells.

-------------------------
Between 1912 and 1922 Schoenberg came to realize that he was searching for a new method of composition that would provide a new basis for musical structure to replace the old basis of tonality, which he felt was being stretched and distorted too much to remain a unifying structural principle. Instead of using 1 or 2 tones as main points of focus for an entire composition (as key centres in tonal music), Schoenberg suggested using all 12 tones “related only to one another.” In such a system, unlike tonality, no notes would predominate as focal points, nor would any hierarchy of importance be assigned to the individual tones.

The new unifying principle in composition would then arise from the particular order given to a collection of the 12 tones, an order that would be different for each composition. The basic order for any one composition came to be known as its basic set, its 12-tone row, or its 12-tone series, all of which terms are synonymous. The basic set for Schoenberg’s Wind Quintet (1924) is E♭–G–A–B–C♯–C–B♭–D–E–F♯–A♭–F; for his String Quartet No. 4 (1936) it is D–C♯–A–B♭–F–E♭–E–C–A♭–G–F♯–B.

The basic set is not a theme, for it has no specific shape, rhythm, or loudness. It is a backbone, a musical idea that permeates the composition in which it is used. Because of the various principles of composing and manipulating the basic set recognized by Schoenberg and others, it is not often possible nor even desirable to hear the basic set when the composition is performed. This situation has led many people to attack Schoenberg’s method as unmusical and as mathematical madness. Such views seem unjustifiable, because, as Schoenberg pointed out, his method specifies only a tiny fraction of the total nature of a composition—certainly no more than composing with tonality specifies.

Twelve-tone music is an example of serialism (q.v.) in music.

-------------------------
Serialism, in music, technique that has been used in some musical compositions roughly since World War I. Strictly speaking, a serial pattern in music is merely one that repeats over and over for a significant stretch of a composition. In this sense, some medieval composers wrote serial music, because they made use of isorhythm, which is a distinct rhythmic pattern that repeats many times regardless of what melodies it belongs to. Another pre-20th-century example of serialism is the ground bass, a pattern of harmonies or of melody that repeats, most often in the lower vocal or instrumental parts of a composition. Countless numbers of composers have written music with a ground bass. The term serial music is often used interchangeably with 12-tone music (q.v.), but the latter is more properly an example of the former.


-------------------------

Support microtonal notes with Pitch changes:

The two bytes of the pitch bend message form a 14 bit number, 0 to 16383. The value 8192 (sent, LSB first, as 0x00 0x40), is centered, or "no pitch bend." The value 0 (0x00 0x00) means, "bend as low as possible," and, similarly, 16383 (0x7F 0x7F) is to "bend as high as possible." The exact range of the pitch bend is specific to the synthesizer. 

Pitch Bend Range: 
RPN LSB = 0: Bn 64 00 
RPN MSB = 0: Bn 65 00 
Data MSB: Bn 06 mm (mm sets bend range in semitones. mm can be from 00 to 18 for 0 to 24 (+/- 12) semitones both up and down) 
Data LSB=0 (usually not required): Bn 26 00
So to set Pitch Bend Range to +/- 12 semitones:
HEX      ; DECIMAL
Bn 65 00 ; 101 00 MSB
Bn 64 00 ; 100 00 LSB
Bn 06 18 ;  06 24 MSB
Bn 26 00 ;  38 00 LSB

RPN & NRPN Reset:
RPN LSB = 7F: Bn 64 7F 
RPN MSB = 7F: Bn 65 7F 
Send this alone (no data messages) immediately after all other RPN and NRPN messages have been sent.          


------------------------------------------------------



//////////////// http://alpha.editor.p5js.org/generative-design/sketches/P_2_1_3_01

var count = 0;
var tileCountX = 10;
var tileCountY = 10;
var tileWidth  = 0;
var tileHeight = 0;

var colorStep = 15;

var circleCount = 0;
var endSize = 0;
var endOffset = 0;

var actRandomSeed = 0;

function setup()
{
    createCanvas(800, 800);
    tileWidth = width / tileCountX;
    tileHeight = height / tileCountY;
    noFill();
    stroke(0, 128);
}

function draw()
{
    background(255);
    randomSeed(actRandomSeed);

    translate(tileWidth / 2, tileHeight / 2);

    circleCount = mouseX / 30 + 1;
    endSize = map(mouseX, 0, max(width, mouseX), tileWidth / 2, 0);
    endOffset = map(mouseY, 0, max(height, mouseY), 0, (tileWidth - endSize) / 2);

    for (var gridY = 0; gridY <= tileCountY; gridY++)
    {
        for (var gridX = 0; gridX <= tileCountX; gridX++)
        {
            push();
            translate(tileWidth * gridX, tileHeight * gridY);
            scale(1, tileHeight / tileWidth);

            var toggle = int(random(0, 4));
            if (toggle == 0) rotate(-HALF_PI);
            if (toggle == 1) rotate(0);
            if (toggle == 2) rotate(HALF_PI);
            if (toggle == 3) rotate(PI);

            // draw module
            for (var i = 0; i < circleCount; i++)
            {
                var diameter = map(i, 0, circleCount, tileWidth, endSize);
                var offset = map(i, 0, circleCount, 0, endOffset);
                ellipse(offset, 0, diameter, diameter);
            }
            pop();
        }
    }
}

function mousePressed()
{
    actRandomSeed = random(100000);
}

function keyReleased()
{
    if (key == 's' || key == 'S') saveCanvas(gd.timestamp(), 'png');
}




//////////////// http://alpha.editor.p5js.org/generative-design/sketches/P_2_1_2_04

var tileCount = 20;
var actRandomSeed = 0;

var rectSize = 30;

function setup()
{
    createCanvas(600, 600);
    colorMode(HSB, 360, 100, 100, 100);
    noStroke();
    fill(192, 100, 64, 60);
}

function draw()
{
    clear();

    randomSeed(actRandomSeed);

    for (var gridY = 0; gridY < tileCount; gridY++)
    {
        for (var gridX = 0; gridX < tileCount; gridX++)
        {

            var posX = width / tileCount * gridX;
            var posY = height / tileCount * gridY;

            var shiftX1 = mouseX / 20 * random(-1, 1);
            var shiftY1 = mouseY / 20 * random(-1, 1);
            var shiftX2 = mouseX / 20 * random(-1, 1);
            var shiftY2 = mouseY / 20 * random(-1, 1);
            var shiftX3 = mouseX / 20 * random(-1, 1);
            var shiftY3 = mouseY / 20 * random(-1, 1);
            var shiftX4 = mouseX / 20 * random(-1, 1);
            var shiftY4 = mouseY / 20 * random(-1, 1);

            push();
            translate(posX, posY);
            beginShape();
            vertex(shiftX1, shiftY1);
            vertex(rectSize + shiftX2, shiftY2);
            vertex(rectSize + shiftX3, rectSize + shiftY3);
            vertex(shiftX4, rectSize + shiftY4);
            endShape();
            pop();
        }
    }
}

function mousePressed()
{
    actRandomSeed = random(100000);
}

function keyReleased()
{
    if (key == 's' || key == 'S') saveCanvas(gd.timestamp(), 'png');
}

