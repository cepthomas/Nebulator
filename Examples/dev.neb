
///// Tester for dev features.


///// Constants /////
// When to play.
WHEN1 = constant(0);
WHEN2 = constant(32);
WHEN3 = constant(64);
WHEN4 = constant(96);
// Total length.
TLEN = constant(128);
// Volumes.
KEYS_DEF_VOL = constant(100);
DRUM_DEF_VOL = constant(100);

///// Variables /////
COL1 = variable(200); // change color
MODN = variable(0); // modulate notes
PITCH = variable(8192); // center is 8192

///// Realtime Controllers /////
MI1 = midiin(1, 4, MODN);
MO1 = midiout(1, Pitch, PITCH);

////// Levers //////
L1 = lever(0, 255, COL1);
L2 = lever(0, 16383, PITCH); // max range
L3 = lever(-10, 10, MODN);


///// Tracks and Loops /////
KEYS = track(1, 5, 0, 0); // wobbles
BASS = track(2, 2, 0, 0); // wobbles
DRUMS = track(10, 4, 0, 0); // wobbles
SYNTH = track(3, 0);


////// Drums //////
// Using patterns. Each hit is 1/16 note - fixed res for now.
DRUMS_SIMPLE = sequence(8);
note(x-------x-------x-------x-------, AcousticBassDrum, 90);
note(----x-------x-x-----x-------x-x-, AcousticSnare, 80);

////// Sequenced triggered in script //////
DSEQ1 = sequence(8);
note(0.00, G.3, 90, 0.60);
note(1.00, A.3, 90, 0.60);
note(2.00, Bb.3, 90, 0.60);
note(3.00, C.4, 90, 0.60);

DSEQ2 = sequence(12);
note(2.00, G#.3, 90, 0.60);
note(5.00, A#.3, 90, 0.60);
note(9.00, B.3, 90, 0.60);
note(11.00, C#.4, 90, 0.60);

DSEQ3 = sequence(19);
note(7.00, F.3, 90, 0.60);
note(12.00, F#.3, 90, 0.60);
note(14.00, E.3, 90, 0.60);
note(16.00, Eb.4, 90, 0.60);



/////////////////////////////////////////////

///// Functions /////

int[] scaleNotes;
int[] notesPlaying;

public override void setup()
{
    println("setup()");
    scaleNotes = getScaleNotes("Algerian", "G.4");
    println("scaleNotes", scaleNotes.Length);
    notesPlaying = new int[scaleNotes.Length];

    // Patches (optional). Only needed if using the Windows GM.
    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Pad3Polysynth);
    }
}


public override void step()
{
    if(tock == 0)
    {
        algoSequences();
        //algoRandom();
    }
}

void algoSequences() // ???? oops can't do loopy stuff like this with midi!
{
    if(tick % 9 == 0)
    {
        playSequence(KEYS, DSEQ1);
    }

    if(tick % 13 == 0)
    {
        playSequence(KEYS, DSEQ2);
    }

    if(tick % 20 == 0)
    {
        playSequence(KEYS, DSEQ3);
    }
}

void algoRandom()
{
    if(random(3) == 0)
    {
        int which = random(scaleNotes.Length);

        if(notesPlaying[which] == 0)
        {
            int dur = random(4, 20);
            notesPlaying[which] = tick + dur;
            sendMidiNote(KEYS, scaleNotes[which], 95, dur);
        }
    }

    // Turn off any scheduled to stop now.
    for(int i = 0;i < notesPlaying.Length;i++)
    {
        if(notesPlaying[i] != 0 && notesPlaying[i] == tick)
        {
            sendMidiNote(KEYS, scaleNotes[i], 0, 0.00);
            notesPlaying[i] = 0;
        }
    }
}

public void On_MODN()
{
    println("MODN changed to", MODN);
    modulate(KEYS, MODN);
}

public override void draw()
{
    background(COL1, 100, 200);

    // Recursive:
    // noLoop(); // run once only
    // drawRecursive(0, 0, width / 2, 1); // TODO2 This uses a whole core with GDI
    // return;

    if (mousePressedP)
    {
        //println("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, scaleNotes[0], scaleNotes[scaleNotes.Length-1]);
    sendMidiNote(SYNTH, sn, 90, 0.48);
}


///// Tester for recursive rendering - chokes Script.draw()
void drawRecursive(float x, float y, float squareSize, float minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
