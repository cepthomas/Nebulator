
// Akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.


// Use win gm and virtual kbd only. Otherwise all midi.
bool _minimal = true;


// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable KBD_NOTE;
NVariable VKBD_NOTE;
NVariable CTL2;
NVariable CTL3;

// All the output channels.
NChannel PIANO;
NChannel BASS;
NChannel SYNTH;
NChannel DRUMS;

// All the sequences
NSequence PIANO_MAIN;
NSequence DRUMS_SIMPLE;
NSequence DRUMS_VERSE;

// Constants
const double KEYS_DEF_VOL = 0.8;
const double DRUM_DEF_VOL = 0.8;


// Neb script stuff.
double[] _chordNotes;
double[] _scaleNotes;
int _noteNum = 0;
// Index is integer note number, value is when to stop it.
int[] _notesPlaying = new int[128];


// IO device names.
string MIDI_IN = "MIDI:MPK mini";
string MIDI_OUT = "MIDI:loopMIDI Port 1";
string OSC_IN = "OSC:6448";
string OSC_OUT = "OSC:127.0.0.1:1234";
string GS_MIDI_OUT = "MIDI:Microsoft GS Wavetable Synth";


// When to play sequences.
const int PART1 = 0;
const int PART2 = 32;
const int PART3 = 48;
const int PART4 = 80;
const int END = 90;

// Where we are now.
int _section = 0;


public override void Setup()
{
    // All the neb variables.
    CTL2 = CreateVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = CreateVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = CreateVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = CreateVariable("mod", 127, 0, 255, On_MOD1);
    KBD_NOTE = CreateVariable("note", 60, -127, 127, On_KBD_NOTE); // note neg number for note off encoding
    VKBD_NOTE = CreateVariable("note", 60, -127, 127, On_VKBD_NOTE);

    // IO devices.
    if(_minimal)
    {
        // All the outputs.
        PIANO = CreateChannel("piano", GS_MIDI_OUT, 1);
        BASS = CreateChannel("bass", GS_MIDI_OUT, 2);
        SYNTH = CreateChannel("synth", GS_MIDI_OUT, 3);
        DRUMS = CreateChannel("drums", GS_MIDI_OUT, 10);

        // All the inputs.
        CreateController("VKEY:", 1, NoteControl, VKBD_NOTE);
    }
    else
    {
        // All the outputs.
        PIANO = CreateChannel("piano", MIDI_OUT, 1);
        BASS = CreateChannel("bass", MIDI_OUT, 2);
        SYNTH = CreateChannel("synth", MIDI_OUT, 3);
        DRUMS = CreateChannel("drums", MIDI_OUT, 10);

        // All the inputs.
        // CreateController(MIDI_IN, 1, 1, MOD1); // modulate eq
        // CreateController(MIDI_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
        // CreateController(MIDI_IN, 1, 3, CTL3); // another controller
        // CreateController(MIDI_IN, 1, 4, BACK_COLOR); // change ui color
        // CreateController(MIDI_IN, 1, NoteControl, KBD_NOTE);
    }

    SetWobbler(PIANO, 0.2);
    SetWobbler(BASS, 0.1);
    SetWobbler(DRUMS, 0.1);

    // levers
    CreateLever(BACK_COLOR);
    CreateLever(MOD1);

    // create set of notes (chord)
    CreateNotes("CHORD", "1 4 6 b13");
    CreateNotes("SCALE", "1 3 4 b7");

    // Get some stock chords and scales
    _chordNotes = GetNotes("C4.o7");
    _scaleNotes = GetScaleNotes("Algerian", "A3");

    // Create sequences, add notes/chords/funcs.
    PIANO_MAIN = CreateSequence(8);
    PIANO_MAIN.Add(00.00,  "G3",          0.7,  0.60);
    PIANO_MAIN.Add(01.00,  "D3",          0.7,  0.60);
    PIANO_MAIN.Add(02.00,  "A3.m7",       0.7,  0.60);
    PIANO_MAIN.Add(03.00,  66,            0.7,  0.60);
    PIANO_MAIN.Add(03.48,  CrashCymbal1,  0.7,  0.60);
    PIANO_MAIN.Add(05.50,  FuncPiano,     0.7);
    PIANO_MAIN.Add(06.24,  52,            0.7,  0.60);

    DRUMS_SIMPLE = CreateSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------",  AcousticBassDrum, 0.7);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-",  AcousticSnare,    0.6);
    DRUMS_SIMPLE.Add("------xx------xx------xx------xx",  ClosedHiHat,      0.8);

    DRUMS_VERSE = CreateSequence(8);
    DRUMS_VERSE.Add(0.00,  AcousticBassDrum,  DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.00,  RideCymbal1,       DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.10,  RideCymbal1,       DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.60,  HiMidTom,          DRUM_DEF_VOL);
    DRUMS_VERSE.Add(2.00,  AcousticBassDrum,  DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.00,  RideCymbal1,       DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.10,  RideCymbal1,       DRUM_DEF_VOL);
    DRUMS_VERSE.Add(4.00,  AcousticBassDrum,  DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.00,  RideCymbal1,       DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.10,  RideCymbal1,       DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.60,  HiMidTom,          DRUM_DEF_VOL);
    DRUMS_VERSE.Add(6.00,  AcousticBassDrum,  DRUM_DEF_VOL);
    DRUMS_VERSE.Add(7.00,  CrashCymbal2,      DRUM_DEF_VOL);

    // Important times/states.
    CreateSection(PART1, "Beginning");
    CreateSection(PART2, "Middle");
    CreateSection(PART3, "Chorus");
    CreateSection(PART4, "Ending");
    CreateSection(END, "Finito");
}

public override void Setup2()
{
    if(_minimal)
    {
        SendPatch(PIANO, AcousticGrandPiano);
        SendPatch(BASS, AcousticBass);
        SendPatch(SYNTH, Lead1Square);
        SendPatch(DRUMS, 32);
    }
}


public override void Step()
{
    if(Tock != 0) // not looking at Tocks right now
    {
        return;
    }

    // Offset from start of section.
    int tickOffset = Tick - CurrentSection;

    // Do work.
    switch(CurrentSection)
    {
        case PART1: DoSect1(tickOffset); break;
        case PART2: DoSect2(tickOffset); break;
        case PART3: DoSect3(tickOffset); break;
        case PART4: DoSect4(tickOffset); break;
        case END:            break;
    }

    // // Tracker-like model.
    // // SKIP means keep going, no new directive
    // // MUTE means mute
    // COMP    DRUMS           PIANO          BASS
    // // SECT part1
    // 00.00   DRUMS_SIMPLE    PIANO_MAIN     BASS_VERSE
    // 08.00   DRUMS_SIMPLE    PIANO_MAIN     BASS_VERSE
    // 15.00   SKIP            PIANO_MAIN     BASS_VERSE
    // // SECT part2
    // 16.00   DRUMS_VERSE     PIANO_MAIN     BASS_VERSE
    // 17.00   SKIP            MUTE           SKIP
    // 24.00   DRUMS_SIMPLE    PIANO_MAIN     BASS_VERSE
    // // SECT end
    // 32.00   MUTE            MUTE           MUTE
    //
    // if(CurrentSection == PART1)
    // {
    //     Play(00, DRUMS_SIMPLE,    PIANO_MAIN,     BASS_VERSE);
    //     Play(08, DRUMS_SIMPLE,    PIANO_MAIN,     BASS_VERSE);
    //     Play(15, SKIP,            PIANO_MAIN,     BASS_VERSE);
    // }
    // else if(CurrentSection == PART2)
    // {
    //     Play(16, DRUMS_VERSE,     PIANO_MAIN,     BASS_VERSE);
    //     Play(17, SKIP,            MUTE,           SKIP);
    //     Play(24, DRUMS_SIMPLE,    PIANO_MAIN,     BASS_VERSE);
    // }
    // else if(CurrentSection == PART3)
    // {

    // }
    // else if(CurrentSection == PART4)
    // {

    // }




    ///// drums /////
    if(isOneOf(Tick, 0, 8, 24))
    {
        SendSequence(DRUMS, DRUMS_SIMPLE);
    }

    if(isOneOf(Tick, 16))
    {
        SendSequence(DRUMS, DRUMS_VERSE);
    }

    ///// piano /////
    if(isOneOf(Tick, 0, 8, 16))
    {
        SendSequence(PIANO, PIANO_MAIN);
    }

    if(isOneOf(Tick, 26))
    {
        double sn = _scaleNotes[_noteNum++ % _scaleNotes.Count()];
        SendNote(PIANO, sn + Tick % 24, 0.7, 0.28);

        // foreach(int n in _chordNotes)
        // {
        //     SendNote(PIANO, n, 0.7, 1.0);
        // }
    }

    ///// bass /////
    if(isOneOf(Tick % 16, 0, 7, 8))
    {
        SendNote(BASS, 50, 0.8, 2.0);
    }
}

void DoSect1(int tick)
{
    switch(tick)
    {
        case 0:
            SendSequence(DRUMS, DRUMS_SIMPLE);
            SendSequence(PIANO, PIANO_MAIN);
            break;


    }

        // Play(00, DRUMS_SIMPLE,    PIANO_MAIN,     BASS_VERSE);
        // Play(08, DRUMS_SIMPLE,    PIANO_MAIN,     BASS_VERSE);
        // Play(15, SKIP,            PIANO_MAIN,     BASS_VERSE);

}

void DoSect2(int tick)
{
        // Play(16, DRUMS_VERSE,     PIANO_MAIN,     BASS_VERSE);
        // Play(17, SKIP,            MUTE,           SKIP);
        // Play(24, DRUMS_SIMPLE,    PIANO_MAIN,     BASS_VERSE);


}

void DoSect3(int tick)
{


}

void DoSect4(int tick)
{


}



// A called function.
void FuncPiano()
{
    Print("FuncPiano()");

    double sn = _scaleNotes[_noteNum++ % _scaleNotes.Count()];
    SendNote(PIANO, sn + Tick % 24, 0.7, 0.28);
}

public void On_BACK_COLOR()
{
    //Print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}

public void On_CTL2()
{
    int newval = (int)MathUtils.Map(CTL2.Value, 0, 127, 0, 16383);
    //Print("On_CTL2:", newval);
    SendController(SYNTH, PitchControl, newval);
}

public void On_CTL3()
{
    //Print("On_CTL3:", CTL3.Value);
    if(Random(0, 10) == 0)
    {
        SendNote(PIANO, 50 + CTL3.Value % 20, 0.7, 2.0);
    }
}

public void On_MOD1()
{
    //Print(MOD1.Name, "changed to", MOD1.Value);
    // Send a controller change.
    SendController(SYNTH, Modulation, MOD1.Value);
}

public void On_VKBD_NOTE()
{
    //Print("VKBD_NOTE", "=", VKBD_NOTE.Value);

    // Test for note on or off.
    if(VKBD_NOTE.Value > 0)
    {
        SendNoteOn(SYNTH, VKBD_NOTE.Value, 0.9);
    }
    else
    {
        SendNoteOff(SYNTH, -VKBD_NOTE.Value);
    }
}

public void On_KBD_NOTE()
{
    //Print("KBD_NOTE", "=", KBD_NOTE.Value);

    // Test for note on or off.
    if(KBD_NOTE.Value > 0)
    {
        //SendNoteOn(PIANO, KBD_NOTE.Value, 0.9);
        SendNoteOn(SYNTH, KBD_NOTE.Value, 0.9);
        //SendNote(SYNTH, KBD_NOTE.Value, 0.8, 2.0); // fixed duration
    }
    else
    {
        //SendNoteOff(PIANO, -KBD_NOTE.Value);
        SendNoteOff(SYNTH, -KBD_NOTE.Value);
    }
}

//////////////////////////////////////////////////////////
void Randish()
{
    if(Tock % 4 == 0 && Random(7) == 0) // play with these for how often
    {
        int which = Random(40, 80);

        if(_notesPlaying[which] == 0) // don't play if already playing
        {
            int dur = Random(1, 8);
            _notesPlaying[which] = Tick + dur;
            SendNote(PIANO, which, Random(0.6, 0.9), dur);
        }

        // Remove any scheduled to stop now.
        for(int i = 0;i < _notesPlaying.Length;i++)
        {
            if(_notesPlaying[i] != 0 && _notesPlaying[i] == Tick)
            {
                _notesPlaying[i] = 0;
            }
        }
    }
}
