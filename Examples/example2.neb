
///// Tester for dev features.


///// Constants /////
// When to play.
WHEN1 = constant(0);
WHEN2 = constant(32);
WHEN3 = constant(64);
WHEN4 = constant(96);
// Total length.
TLEN = constant(128);
// Volumes.
KEYS_DEF_VOL = constant(100);
DRUM_DEF_VOL = constant(100);

///// Variables /////
COL1 = variable(200); // change color
MODN = variable(0); // modulate notes
PITCH = variable(8192); // center is 8192

///// Realtime Controllers /////
MI1 = midiin(1, 4, MODN);
MO1 = midiout(1, Pitch, PITCH);

////// Levers //////
L1 = lever(0, 255, COL1);
L2 = lever(0, 16383, PITCH); // max range
L3 = lever(-10, 10, MODN);


///// Tracks and Loops /////
KEYS = track(1, 5, 0, 0); // wobbles
loop(WHEN1, WHEN2, KEYS_VERSE1);
loop(WHEN2, WHEN3, KEYS_VERSE2);
loop(WHEN3, WHEN4, KEYS_VERSE1);
loop(WHEN4, TLEN, KEYS_VERSE2);

BASS = track(2, 2, 0, 0); // wobbles
loop(WHEN1, TLEN, BASS_VERSE);

DRUMS = track(10, 4, 0, 0); // wobbles
loop(WHEN1, TLEN, DRUMS_SIMPLE);

SYNTH = track(3, 0);


///// Sequences and Notes /////

////// Keys //////
KEYS_VERSE1 = sequence(16);
note(0.00, G.4.m7, 90, 1.48);
note(1.70, G.4.m7, 90, 0.10);
note(2.00, G.4.m7, 90, 0.10);
note(4.00, G.4.m7, 90, 1.48);
note(5.70, G.4.m7, 90, 0.10);
note(6.00, G.4.m7, 90, 0.10);
note(8.00, G.4.m6, 90, 1.48);
note(9.70, G.4.m6, 90, 0.10);
note(10.00, G.4.m6, 90, 0.10);
note(12.00, G.4.m6, 90, 1.48);
note(13.70, G.4.m6, 90, 0.10);
note(14.00, G.4.m6, 90, 0.10);

KEYS_VERSE2 = sequence(8);
note(0.00, F.4.???, 90, 0.48);
note(0.48, D#.4, KEYS_DEF_VOL, 0.48);
note(1.00, C.4, 90, 0.48);
note(1.48, B.4.m7, 90, 0.48);
note(2.00, F.5, 90, 0.48);
note(2.48, D#.5, KEYS_DEF_VOL, 0.48);
note(3.00, C.5, 90, 0.48);
note(3.48, B.5.m7, 90, 0.48);
note(4.00, F.3, 90, 0.48);
note(4.48, D#.3, KEYS_DEF_VOL, 0.48);
note(5.00, C.3, 90, 0.48);
note(5.48, B.3.m7, 90, 0.48);
note(6.00, F.2, 90, 0.48);
note(6.48, D#.2, KEYS_DEF_VOL, 0.48);
note(7.00, C.2, 90, 0.48);
note(7.48, B.2.m7, 90, 0.48);

////// Bass //////
BASS_VERSE = sequence(8);
note(0.00, C.2, 70, 0.25);
note(0.75, C.2, 70, 0.1/8);
note(3.48, E.2, 70, 0.25);
note(4.00, C.2, 70, 1.00);
note(7.75, A#.2, 70, 0.10);

////// Drums //////


// Using patterns. Each hit is 1/16 note - fixed res for now.
DRUMS_SIMPLE = sequence(8);
note(x-------x-------x-------x-------, AcousticBassDrum, 90);
note(----x-------x-x-----x-------x-x-, AcousticSnare, 80);

////// Sequenced triggered in script //////
DSEQ1 = sequence(8);
note(0.00, G.3, 90, 0.60);
note(1.00, A.3, 90, 0.60);
note(2.00, Bb.3, 90, 0.60);
note(3.00, C.4, 90, 0.60);

DSEQ2 = sequence(12);
note(2.00, G.3, 90, 0.60);
note(5.00, A.3, 90, 0.60);
note(9.00, Bb.3, 90, 0.60);
note(11.00, C.4, 90, 0.60);

DSEQ3 = sequence(19);
note(7.00, G.3, 90, 0.60);
note(12.00, A.3, 90, 0.60);
note(14.00, Bb.3, 90, 0.60);
note(16.00, C.4, 90, 0.60);



/////////////////////////////////////////////

///// Functions /////

// Simple variables for functions.
float posX = 50;
float posY = 50;
int velX = 3;
int velY = 3;
int ballSize = 40;
int[] scaleNotes;

int[] notesPlaying;



public override void setup()
{
    println("setup()");
    scaleNotes = getScaleNotes("Algerian", "G.4");
    println("scaleNotes", scaleNotes.Length);
    notesPlaying = new int[scaleNotes.Length];

    // Patches (optional). Only needed if using the Windows GM.
    sendPatch(KEYS, AcousticGrandPiano);
    sendPatch(BASS, AcousticBass);
    sendPatch(SYNTH, Pad3Polysynth);
}


public override void step()
{
    if(tock == 0)
    {
        algoSequences();
        //algoRandom();
    }
}

void algoSequences() // oops can't do loopy stuff like this with midi!
{
    if(tick % 9 == 0)
    {
        playSequence(KEYS, DSEQ1);
    }

    if(tick % 13 == 0)
    {
        playSequence(KEYS, DSEQ2);
    }

    if(tick % 20 == 0)
    {
        playSequence(KEYS, DSEQ3);
    }
}

void algoRandom()
{
    if(random(3) == 0)
    {
        int which = random(scaleNotes.Length);

        if(notesPlaying[which] == 0)
        {
            int dur = random(4, 20);
            notesPlaying[which] = tick + dur;
            sendMidiNote(KEYS, scaleNotes[which], 95, dur);
        }
    }

    // Turn off any scheduled to stop now.
    for(int i = 0;i < notesPlaying.Length;i++)
    {
        if(notesPlaying[i] != 0 && notesPlaying[i] == tick)
        {
            sendMidiNote(KEYS, scaleNotes[i], 0, 0.00);
            notesPlaying[i] = 0;
        }
    }
}

public void On_MODN()
{
    println("MODN changed to", MODN);
    modulate(KEYS, MODN);
}

public override void draw()
{
    background(COL1, 100, 200);

    // Recursive:
    // noLoop(); // run once only
    // drawRecursive(0, 0, width / 2, 1); // TODO2 This uses a whole core with GDI
    // return;

    if (mousePressedP)
    {
        //println("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, scaleNotes[0], scaleNotes[scaleNotes.Length-1]);
    sendMidiNote(SYNTH, sn, 90, 0.48);
}


///// Tester for recursive rendering - chokes Script.draw()
void drawRecursive(float x, float y, float squareSize, float minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
