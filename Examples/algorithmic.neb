// Algorithmic Nebulator file with simple animation.

///// Include other lib files. /////
include(utils.neb);


///// Constants /////
// When to play.
PART1 = const(0);
PART2 = const(64);
PART3 = const(128);
PART4 = const(192);
// Total length.
TLEN = const(256);
// Volumes.
KEYS_DEF_VOL = const(100);
DRUM_DEF_VOL = const(100);

///// Variables /////
NOTE = var(60); // to play
MODN = var(0); // modulate notes
PITCH = var(8192); // center is 8192
BACKC = var(200); // change background

///// Realtime Controllers /////
MI1 = midiin(1, 2, SPEED);
MI2 = midiin(1, 3, VOLUME);
MI3 = midiin(1, 4, MODN);
MO1 = midiout(1, Pitch, PITCH);

////// Levers //////
L1 = lever(0, 255, NOTE);
L2 = lever(0, 16383, PITCH); // max range
L3 = lever(-10, 10, MODN);
L4 = lever(0, 255, BACKC);

///// Tracks /////
KEYS = track(1, 5);
BASS = track(2, 2);

///// Functions /////

// Simple variables for functions.
float posX = 50;
float posY = 50;
int velX = 3;
int velY = 3;
int ballSize = 40;
int notenum = 60;

////// Nebulator midi stuff //////
public override void step()
{
    // The simple algorithm.
    if(tock % 25 == 0)
    {
        int notenum = tick % 2 == 0 ? 50 : 60;
        notenum += tock / 20;
        sendMidiNote(KEYS, notenum, KEYS_DEF_VOL, 1.09);
    }
}

public void On_MODN()
{
    println("MODN changed to", MODN);
    modulate(KEYS, MODN);
}

////// Nebulator graphics stuff //////
public override void setup()
{
    println("setup()");

    // Patches (optional). Really only needed if using the Windows GM.
    sendPatch(KEYS, AcousticGrandPiano);
    sendPatch(BASS, AcousticBass);
}

public override void draw()
{
    background(BACKC, 100, 200);

    if(playing && moveBall())
    {
        boing(notenum - 12);
    }

    // Draw the ball.
    noStroke();
    ellipse(posX, posY, ballSize, ballSize);
    int x = (int)map(posX, 0, width, 0, 255);
    PColor c = color(x, (x + 100) % 256, (x + 200) % 256);
    fill(c);
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int x = (int)map(mouseX, 0, width, 40, 100);
    sendMidiNote(KEYS, x, KEYS_DEF_VOL, 1.50);
}

public override void keyPressed()
{
    int v = key == 'c' ? 60 : 70;
    sendMidiNote(KEYS, v, KEYS_DEF_VOL, 1.50);
}

bool moveBall()
{
    bool edge = false;

    ///// Move the ball. /////
    posX += velX;
    if (posX <= ballSize / 2)
    {
        posX = ballSize / 2;
        velX = -velX;
        edge = true;
    }
    else if (posX >= width - ballSize / 2)
    {
        posX = width - ballSize / 2;
        velX = -velX;
        edge = true;
    }

    posY += velY;
    if (posY <= ballSize / 2)
    {
        posY = ballSize / 2;
        velY = -velY;
        edge = true;
    }
    else if (posY >= height - ballSize / 2)
    {
        posY = height - ballSize / 2;
        velY = -velY;
        edge = true;
    }
    return edge;
}