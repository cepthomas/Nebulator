
// Example Nebulator composition file with some UI demo.
// Warning: this is not actual music!

///// Include other lib files. /////
$load "utils.np"
$load "scale.np"


///// Constants /////
// When to play.
const int WHEN1 = 0;
const int WHEN2 = 32;
const int WHEN3 = 48;
const int WHEN4 = 80;
// Total length.
const int TLEN = 128;
// Volumes.
const double KEYS_DEF_VOL = 0.8;
const double DRUM_DEF_VOL = 0.8;

///// Variables /////
NVariable COL1;
NVariable MODN;
NVariable VKBD_NOTE;

///// Channels /////
NChannel KEYS;
NChannel BASS;
NChannel DRUMS;
NChannel SYNTH;

////////// Sections //////////
NSection SECTION1;
NSection SECTION2;
NSection SECTION3;

///// Sequences /////
NSequence KEYS_VERSE1;
NSequence KEYS_VERSE2;
NSequence BASS_VERSE;
NSequence DRUMS_VERSE;
NSequence DRUMS_SIMPLE;
NSequence DYNAMIC_SEQ;
NSequence ALGO_SEQ;
NSequence NULL_SEQ;


////// Simple variables for functions. ///////
double _posX = 50;
double _posY = 50;
int _velX = 3;
int _velY = 3;
int _ballSize = 40;
double[] _scaleNotes;
double[] _chordNotes;

// Use wingm and virtual kbd only.
bool _local = true;


////// Nebulator midi stuff //////
public override void setupNeb()
{
    string MY_MIDI_OUT = _local ? "Microsoft GS Wavetable Synth" : "or whatever you like";

    // All the neb variables.
    COL1 = createVariable("color", 200, 0, 255); // change color
    MODN = createVariable("modn", 0, -10, 10);
    VKBD_NOTE = createVariable("note", 60, -127, 127, On_VKBD_NOTE);

    // All the channels.
    KEYS = createChannel("keys", MY_MIDI_OUT, 1, 0.1);
    BASS = createChannel("bass", MY_MIDI_OUT, 2, 0.1);
    SYNTH = createChannel("synth", MY_MIDI_OUT, 3, 0);
    DRUMS = createChannel("drums", MY_MIDI_OUT, 10, 0.1);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // levers
    createLever(COL1);
    createLever(MODN);

    createController("Virtual Keyboard", 0, NoteControl, VKBD_NOTE);

    ///// Sequences /////
    KEYS_VERSE1 = createSequence(16);
    KEYS_VERSE1.Add(0.00,  "G4.m7", 0.7, 1.32);
    KEYS_VERSE1.Add(1.60,  "G4.m7", 0.7, 0.20);
    KEYS_VERSE1.Add(2.00,  "G4.m7", 0.7, 0.20);
    KEYS_VERSE1.Add(4.00,  "G4.m7", 0.7, 1.32);
    KEYS_VERSE1.Add(5.60,  "G4.m7", 0.7, 0.20);
    KEYS_VERSE1.Add(6.00,  "G4.m7", 0.7, 0.20);
    KEYS_VERSE1.Add(8.00,  "G4.m6", 0.7, 1.32);
    KEYS_VERSE1.Add(9.60,  "G4.m6", 0.7, 0.20);
    KEYS_VERSE1.Add(10.00, "G4.m6", 0.7, 0.20);
    KEYS_VERSE1.Add(12.00, "G4.m6", 0.7, 1.32);
    KEYS_VERSE1.Add(13.60, "G4.m6", 0.7, 0.20);
    KEYS_VERSE1.Add(14.00, "G4.m6", 0.7, 0.20);

    KEYS_VERSE2 = createSequence(8);
    KEYS_VERSE2.Add(0.00, "F4",    0.7, 0.32);
    KEYS_VERSE2.Add(0.32, "D#4",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(1.00, "C4",    0.7, 0.32);
    KEYS_VERSE2.Add(1.32, "B4.m7", 0.7, 0.32);
    KEYS_VERSE2.Add(2.00, "F5",    0.7, 0.32);
    KEYS_VERSE2.Add(2.32, "D#5",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(3.00, "C5",    0.7, 0.32);
    KEYS_VERSE2.Add(3.32, "B5.m7", 0.7, 0.32);
    KEYS_VERSE2.Add(4.00, "F3",    0.7, 0.32);
    KEYS_VERSE2.Add(4.32, "D#3",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(5.00, "C3",    0.7, 0.32);
    KEYS_VERSE2.Add(5.32, "B3.m7", 0.7, 0.32);
    KEYS_VERSE2.Add(6.00, "F2",    0.7, 0.32);
    KEYS_VERSE2.Add(6.32, "D#2",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(7.00, "C2",    0.7, 0.32);
    KEYS_VERSE2.Add(7.32, "B2.m7", 0.7, 0.32);

    ////// Bass //////
    BASS_VERSE = createSequence(8);
    BASS_VERSE.Add(0.00, "C2",  0.75, 0.25);
    BASS_VERSE.Add(0.48, "C2",  0.75, 0.125);
    BASS_VERSE.Add(3.32, "E2",  0.75, 0.25);
    BASS_VERSE.Add(4.00, "C2",  0.75, 1.00);
    BASS_VERSE.Add(7.48, "A#2", 0.75, 0.10);

    ////// Drums //////

    // "musical"
    DRUMS_VERSE = createSequence(8);
    DRUMS_VERSE.Add(0.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.60, HiMidTom,         DRUM_DEF_VOL);
    DRUMS_VERSE.Add(2.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(4.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.60, HiMidTom,         DRUM_DEF_VOL);
    DRUMS_VERSE.Add(6.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(7.00, CrashCymbal2,     DRUM_DEF_VOL);

    // Using patterns. Each hit is 1/16 note - fixed resolution and volume for now.
    DRUMS_SIMPLE = createSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 0.8);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare,    0.7);
    DRUMS_SIMPLE.Add("------xx------xx------xx------xx", ClosedHiHat,      0.9);

    // Sequence triggered in script
    DYNAMIC_SEQ = createSequence(8);
    DYNAMIC_SEQ.Add(0.00, "G3 ", 0.75, 0.60);
    DYNAMIC_SEQ.Add(1.00, "A3 ", 0.75, 0.60);
    DYNAMIC_SEQ.Add(2.00, "Bb3", 0.75, 0.60);
    DYNAMIC_SEQ.Add(3.00, "C4 ", 0.75, 0.60);

    // Sequence that calls a script function.
    ALGO_SEQ = createSequence(8);
    ALGO_SEQ.Add(00.00, algoDynamic, 0.75);

    NULL_SEQ = createSequence(8);
    NULL_SEQ.Add(00.00, algoNull, 0.75);

    // Sections
    SECTION1 = createSection("section1", WHEN1, WHEN2 - WHEN1);
    SECTION1.Add(KEYS, KEYS_VERSE1, KEYS_VERSE1);
    SECTION1.Add(DRUMS, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE);
    SECTION1.Add(BASS, BASS_VERSE, BASS_VERSE, BASS_VERSE, BASS_VERSE);

    SECTION2 = createSection("section2", WHEN2, WHEN3 - WHEN2);
    SECTION2.Add(KEYS, KEYS_VERSE2, KEYS_VERSE2);
    SECTION2.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);
    SECTION2.Add(BASS, BASS_VERSE, BASS_VERSE);
    SECTION2.Add(SYNTH, NULL_SEQ, ALGO_SEQ);

    SECTION3 = createSection("section3", WHEN3, WHEN4 - WHEN3);
    SECTION3.Add(KEYS, KEYS_VERSE1, KEYS_VERSE1);
    SECTION3.Add(DRUMS, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE);
    SECTION3.Add(BASS, BASS_VERSE, BASS_VERSE, BASS_VERSE, BASS_VERSE);

    // Get some stock chords and scales
    _scaleNotes = getScaleNotes("Algerian", "A3");
    _chordNotes = getNotes("C4.o7");
}

public override void step()
{
    if(tick == 0 && tock == 0 && _local)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Lead1Square);
        sendPatch(DRUMS, 32); // kit
    }

    // Play a sequence periodically.
    if(tock == 0)
    {
        // On the one - time to do something.
        switch(tick)
        {
            case 0:
                sendNote(SYNTH, "F3", 0.8, 0.48);
                break;
            case 16:
                sendSequence(SYNTH, DYNAMIC_SEQ);
                break;

            case 8:
                sendNoteOn(SYNTH, 62, 0.8); // numbered note on, no chase
                break;

            case 12:
                sendNoteOff(SYNTH, 62); // numbered note off
                break;

            case 24:
            case 25:
            case 26:
            case 27:
                int notenum = random(40, 70);
                sendNote(SYNTH, notenum, 0.8, 1.09);
                break;
        }
    }
}

void algoDynamic()
{
    // print("!!!! algoDynamic");
    int notenum = random(40, 70);
    sendNote(SYNTH, notenum, 0.8, 0.30);
}

void algoNull()
{
    // print("!!!! algoNull");
}

public void On_VKBD_NOTE()
{
    //print("VKBD_NOTE", "=", VKBD_NOTE.Value);

    // Test for note on or off.
    if(VKBD_NOTE.Value > 0)
    {
        sendNoteOn(SYNTH, VKBD_NOTE.Value, 0.9);
    }
    else
    {
        sendNoteOff(SYNTH, -VKBD_NOTE.Value);
    }
}

////// Processing graphics stuff //////
public override void setup()
{
    size(400, 400);
    //print("setup()");
}

public override void draw()
{
    background(COL1.Value, COL1.Value, COL1.Value);

    if(playing && moveBall())
    {
        int notenum = random(40, 70);
        // sendNote(SYNTH, notenum, 0.8, 1.09);
    }

    // Draw the ball.
    noStroke();
    int x = (int)map(_posX, 0, width, 0, 255);
    fill(x, (x + 100) % 256, (x + 200) % 256);
    ellipse(_posX, _posY, _ballSize, _ballSize);

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, _scaleNotes[0], _scaleNotes[_scaleNotes.Length-1]);
    sendNote(SYNTH, sn, 0.8, 0.32);
}

public override void keyPressed()
{
    //print("keyPressed:", key);

    int v = key == 'c' ? 60 : 70;
    sendNote(KEYS, v, KEYS_DEF_VOL, 1.32);
}

bool moveBall()
{
    bool edge = false;

    ///// Move the ball. /////
    _posX += _velX;
    if (_posX <= _ballSize / 2)
    {
        _posX = _ballSize / 2;
        _velX = -_velX;
        edge = true;
    }
    else if (_posX >= width - _ballSize / 2)
    {
        _posX = width - _ballSize / 2;
        _velX = -_velX;
        edge = true;
    }

    _posY += _velY;
    if (_posY <= _ballSize / 2)
    {
        _posY = _ballSize / 2;
        _velY = -_velY;
        edge = true;
    }
    else if (_posY >= height - _ballSize / 2)
    {
        _posY = height - _ballSize / 2;
        _velY = -_velY;
        edge = true;
    }
    return edge;
}
