
// Example Nebulator composition file with some UI demo.
// Warning: this is not actual music!

///// Include other lib files. /////
$load "utils.np"
$load "scale.np"


///// Constants /////
// When to play.
const int WHEN1 = 0;
const int WHEN2 = 32;
const int WHEN3 = 48;
const int WHEN4 = 80;
// Total length.
const int TLEN = 128;
// Volumes.
const int KEYS_DEF_VOL = 100;
const int DRUM_DEF_VOL = 100;

///// Variables /////
NVariable COL1;
NVariable MODN;

///// I/O /////
NOutput MIDI_OUT;

///// Channels /////
NChannel KEYS;
NChannel BASS;
NChannel DRUMS;
NChannel SYNTH;

////////// Sections //////////
NSection PART1;
NSection PART2;
NSection PART3;

///// Sequences /////
NSequence KEYS_VERSE1;
NSequence KEYS_VERSE2;
NSequence BASS_VERSE;
NSequence DRUMS_VERSE;
NSequence DRUMS_SIMPLE;
NSequence DYNAMIC_SEQ;
NSequence ALGO_SEQ;
NSequence NULL_SEQ;


////// Simple variables for functions. ///////
float posX = 50;
float posY = 50;
int velX = 3;
int velY = 3;
int ballSize = 40;
int[] scaleNotes;


////// Nebulator midi stuff //////
public override void setupNeb()
{
    bool winGm = false;

    // All the neb variables.
    COL1 = createVariable("color", 200, 0, 255); // change color
    MODN = createVariable("modn", 0, -10, 10);

    // I/O
    MIDI_OUT = createOutput("Microsoft GS Wavetable Synth"); winGm = true; // or your own

    // All the channels.
    KEYS = createChannel("keys", MIDI_OUT, 1, 5);
    BASS = createChannel("bass", MIDI_OUT, 2, 2);
    SYNTH = createChannel("synth", MIDI_OUT, 3, 0);
    DRUMS = createChannel("drums", MIDI_OUT, 10, 4);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // levers
    createLever(COL1);
    createLever(MODN);

    ///// Sequences /////
    KEYS_VERSE1 = createSequence(16);
    KEYS_VERSE1.Add(0.00,  "G4.m7", 90, 1.32);
    KEYS_VERSE1.Add(1.60,  "G4.m7", 90, 0.20);
    KEYS_VERSE1.Add(2.00,  "G4.m7", 90, 0.20);
    KEYS_VERSE1.Add(4.00,  "G4.m7", 90, 1.32);
    KEYS_VERSE1.Add(5.60,  "G4.m7", 90, 0.20);
    KEYS_VERSE1.Add(6.00,  "G4.m7", 90, 0.20);
    KEYS_VERSE1.Add(8.00,  "G4.m6", 90, 1.32);
    KEYS_VERSE1.Add(9.60,  "G4.m6", 90, 0.20);
    KEYS_VERSE1.Add(10.00, "G4.m6", 90, 0.20);
    KEYS_VERSE1.Add(12.00, "G4.m6", 90, 1.32);
    KEYS_VERSE1.Add(13.60, "G4.m6", 90, 0.20);
    KEYS_VERSE1.Add(14.00, "G4.m6", 90, 0.20);

    KEYS_VERSE2 = createSequence(8);
    KEYS_VERSE2.Add(0.00, "F4",    90, 0.32);
    KEYS_VERSE2.Add(0.32, "D#4",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(1.00, "C4",    90, 0.32);
    KEYS_VERSE2.Add(1.32, "B4.m7", 90, 0.32);
    KEYS_VERSE2.Add(2.00, "F5",    90, 0.32);
    KEYS_VERSE2.Add(2.32, "D#5",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(3.00, "C5",    90, 0.32);
    KEYS_VERSE2.Add(3.32, "B5.m7", 90, 0.32);
    KEYS_VERSE2.Add(4.00, "F3",    90, 0.32);
    KEYS_VERSE2.Add(4.32, "D#3",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(5.00, "C3",    90, 0.32);
    KEYS_VERSE2.Add(5.32, "B3.m7", 90, 0.32);
    KEYS_VERSE2.Add(6.00, "F2",    90, 0.32);
    KEYS_VERSE2.Add(6.32, "D#2",   KEYS_DEF_VOL, 0.32);
    KEYS_VERSE2.Add(7.00, "C2",    90, 0.32);
    KEYS_VERSE2.Add(7.32, "B2.m7", 90, 0.32);

    ////// Bass //////
    BASS_VERSE = createSequence(8);
    BASS_VERSE.Add(0.00, "C2",  70, 0.25);
    BASS_VERSE.Add(0.48, "C2",  70, 0.125);
    BASS_VERSE.Add(3.32, "E2",  70, 0.25);
    BASS_VERSE.Add(4.00, "C2",  70, 1.00);
    BASS_VERSE.Add(7.48, "A#2", 70, 0.10);

    ////// Drums //////

    // "musical"
    DRUMS_VERSE = createSequence(8);
    DRUMS_VERSE.Add(0.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.60, HiMidTom,         DRUM_DEF_VOL);
    DRUMS_VERSE.Add(2.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(4.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.60, HiMidTom,         DRUM_DEF_VOL);
    DRUMS_VERSE.Add(6.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(7.00, CrashCymbal2,     DRUM_DEF_VOL);

    // Using patterns. Each hit is 1/16 note - fixed resolution and volume for now.
    DRUMS_SIMPLE = createSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 90);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare,    80);

    // Sequence triggered in script
    DYNAMIC_SEQ = createSequence(8);
    DYNAMIC_SEQ.Add(0.00, "G3 ", 90, 0.60);
    DYNAMIC_SEQ.Add(1.00, "A3 ", 90, 0.60);
    DYNAMIC_SEQ.Add(2.00, "Bb3", 90, 0.60);
    DYNAMIC_SEQ.Add(3.00, "C4 ", 90, 0.60);

    // Sequence that calls a script function.
    ALGO_SEQ = createSequence(8);
    ALGO_SEQ.Add(00.00, algoDynamic, 90);

    NULL_SEQ = createSequence(8);
    NULL_SEQ.Add(00.00, algoNull, 90);

    // Sections
    NSection PART1 = createSection("part1", WHEN1, WHEN2 - WHEN1);
    PART1.Add(KEYS, KEYS_VERSE1, KEYS_VERSE1);
    PART1.Add(DRUMS, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE);
    PART1.Add(BASS, BASS_VERSE, BASS_VERSE, BASS_VERSE, BASS_VERSE);

    NSection PART2 = createSection("part2", WHEN2, WHEN3 - WHEN2);
    PART2.Add(KEYS, KEYS_VERSE2, KEYS_VERSE2);
    PART2.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);
    PART2.Add(BASS, BASS_VERSE, BASS_VERSE);
    PART2.Add(SYNTH, NULL_SEQ, ALGO_SEQ);

    NSection PART3 = createSection("part3", WHEN3, WHEN4 - WHEN3);
    PART3.Add(KEYS, KEYS_VERSE1, KEYS_VERSE1);
    PART3.Add(DRUMS, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE, DRUMS_VERSE);
    PART3.Add(BASS, BASS_VERSE, BASS_VERSE, BASS_VERSE, BASS_VERSE);

    // Get some stock chords and scales
    scaleNotes = getScaleNotes("Algerian", "A3");

    if (winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Pad3Polysynth);
    }
}

public override void step()
{
    // Play a sequence periodically.
    if(tock == 0)
    {
        // On the one - time to do something.
        switch(tick)
        {
            case 0:
                sendNote(SYNTH, "F3", 95, 0.48);
                break;
            case 16:
                playSequence(SYNTH, DYNAMIC_SEQ);
                break;

            case 8:
                sendNoteOn(SYNTH, 62, 95); // numbered note on, no chase
                break;

            case 12:
                sendNoteOff(SYNTH, 62); // numbered note off
                break;

            case 24:
            case 25:
            case 26:
            case 27:
                int notenum = random(40, 70);
                sendNote(SYNTH, notenum, 95, 1.09);
                break;
        }
    }
}

void algoDynamic()
{
    // print("!!!! algoDynamic");
    int notenum = random(40, 70);
    sendNote(SYNTH, notenum, 90, 0.30);
}

void algoNull()
{
    // print("!!!! algoNull");
}

////// Processing graphics stuff //////
public override void setup()
{
    size(800, 800);
    //print("setup()");
}

public override void draw()
{
    background(COL1.Value, COL1.Value, COL1.Value);

    if(playing && moveBall())
    {
        int notenum = random(40, 70);
        // sendNote(SYNTH, notenum, 95, 1.09);
    }

    // Draw the ball.
    noStroke();
    int x = (int)map(posX, 0, width, 0, 255);
    fill(x, (x + 100) % 256, (x + 200) % 256);
    ellipse(posX, posY, ballSize, ballSize);

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, scaleNotes[0], scaleNotes[scaleNotes.Length-1]);
    sendNote(SYNTH, sn, 90, 0.32);
}

public override void keyPressed()
{
    //print("keyPressed:", key);

    int v = key == 'c' ? 60 : 70;
    sendNote(KEYS, v, KEYS_DEF_VOL, 1.32);
}

bool moveBall()
{
    bool edge = false;

    ///// Move the ball. /////
    posX += velX;
    if (posX <= ballSize / 2)
    {
        posX = ballSize / 2;
        velX = -velX;
        edge = true;
    }
    else if (posX >= width - ballSize / 2)
    {
        posX = width - ballSize / 2;
        velX = -velX;
        edge = true;
    }

    posY += velY;
    if (posY <= ballSize / 2)
    {
        posY = ballSize / 2;
        velY = -velY;
        edge = true;
    }
    else if (posY >= height - ballSize / 2)
    {
        posY = height - ballSize / 2;
        velY = -velY;
        edge = true;
    }
    return edge;
}
