
// Akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.

// IO devices.
//string MY_OSC_OUT = "OSC:127.0.0.1:6449";
string MY_OSC_OUT = "OSC:localhost:6449";
string MY_OSC_IN = "OSC:6448";
string MY_VKEY = "Virtual Keyboard";
string MY_MIDI_OUT = "loopMIDI Port 1";
string MY_MIDI_IN = "MPK mini";
string GS_MIDI_OUT = "Microsoft GS Wavetable Synth";

string MY_SYNTH = "Synth1";


// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable KBD_NOTE;
NVariable VKBD_NOTE;
NVariable CTL2;
NVariable CTL3;

// All the output channels.
NChannel PIANO;
NChannel BASS;
NChannel SYNTH;
NChannel DRUMS;

// All the sequences
NSequence SEQ1;
NSequence DRUMS_SIMPLE;

// Sections.
NSection SECTION1;
NSection SECTION2;


// Neb script stuff.
double[] _chordNotes;
double[] _scaleNotes;
int _noteNum = 0;

// Index is note number, value is when to stop it.
int[] _notesPlaying = new int[128];

// Processing stuff.
int _segmentCount = 36;
int _radius = 300;

// Use wingm and virtual kbd only.
bool _local = true;


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

// NChannel SYNX;

// Wrapper wrp;
// SinOsc osc;
// ADSR adsr;
// Filter flt;
// Pan pan;

// Voicer vcr;

// public override void setupNebZZZ()
// {
//     vcr = new Voicer(5);
// }

// public override void setupNebXXX()
// {
//     SYNX = createChannel("synx", MY_SYNTH, 1, 0.2);

//     wrap = new Wrapper();
//     osc = new SinOsc();
//     adsr = new ADSR();
//     filter = new Filter();
//     pan = new Pan();

//     osc.Input = wrap;
//     adsr.Input = osc;
//     filter.Input = adsr;
//     pan.Input = filter;
//     wrap.Output = pan;
    
//     // Start sampling.
//     asioOut.Init(wrap);
//     asioOut.Play(); // start playing - calls wrap.Read()
// }

// void shutDown()
// {
//     // Stop
//     asioOut.Stop(); // TODOX need and IDisposable
//     asioOut.Dispose();
// }

// public void On_CTL3_XXX()
// {
//     sendNote(SYNX, 50 + CTL3.Value % 20, 0.7, 2.0);
//     filter.ControlChange(Modulation, MOD1.Value);
//     //sendController(SYNX, Modulation, MOD1.Value);
// }


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////



public override void setupNeb()
{
    // All the neb variables.
    CTL2 = createVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = createVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = createVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KBD_NOTE = createVariable("note", 60, -127, 127, On_KBD_NOTE); // note neg number for note off encoding
    VKBD_NOTE = createVariable("note", 60, -127, 127, On_VKBD_NOTE);

    if(_local)
    {
        // All the output channels.
        PIANO = createChannel("piano", GS_MIDI_OUT, 1, 0.2);
        BASS = createChannel("bass", GS_MIDI_OUT, 2, 0.1);
        SYNTH = createChannel("synth", GS_MIDI_OUT, 3, 0);
        DRUMS = createChannel("drums", GS_MIDI_OUT, 10, 0.1);

        createController("Virtual Keyboard", 0, NoteControl, VKBD_NOTE);
    }
    else
    {
        // All the output channels.
        PIANO = createChannel("piano", MY_MIDI_OUT, 1, 0.2);
        BASS = createChannel("bass", MY_MIDI_OUT, 2, 0.1);
        SYNTH = createChannel("synth", MY_MIDI_OUT, 3, 0);
        DRUMS = createChannel("drums", MY_MIDI_OUT, 10, 0.1);

        createController(MY_MIDI_IN, 1, 1, MOD1); // modulate eq
        createController(MY_MIDI_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
        createController(MY_MIDI_IN, 1, 3, CTL3); // another controller
        createController(MY_MIDI_IN, 0, 4, BACK_COLOR); // change ui color
        createController(MY_MIDI_IN, 1, NoteControl, KBD_NOTE);
    }

    // createController(MY_OSC_IN, 1, 1, MOD1); // modulate eq
    // createController(MY_OSC_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
    // createController(MY_OSC_IN, 1, 3, CTL3); // another controller
    // createController(MY_OSC_IN, 0, 4, BACK_COLOR); // change ui color


    // levers
    createLever(BACK_COLOR);
    createLever(MOD1);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // Get some stock chords and scales
    _chordNotes = getNotes("C4.o7");
    _scaleNotes = getScaleNotes("Algerian", "A3");

    // Create sequences, add notes/chords/funcs.
    SEQ1 = createSequence(8);
    SEQ1.Add(00.00, "G3", 0.7, 0.60);
    SEQ1.Add(01.00, "D3", 0.7, 0.60);
    SEQ1.Add(02.00, "A3.m7", 0.7, 0.60);
    SEQ1.Add(03.00, 66, 0.7, 0.60);
    SEQ1.Add(03.48, CrashCymbal1, 0.7, 0.60);

    DRUMS_SIMPLE = createSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 0.7);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare, 0.6);
    DRUMS_SIMPLE.Add("------xx------xx------xx------xx", ClosedHiHat, 0.8);

    // Sequence that calls a script function.
    // ALGO_SEQ = createSequence(8);
    // ALGO_SEQ.Add(03.32, algoDynamic, 0.7);
    // NULL_SEQ = createSequence(8);
    // NULL_SEQ.Add(05.16, algoNull, 0.7);

    // Sections
    SECTION1 = createSection("section1", 0, 16);
    SECTION1.Add(PIANO, SEQ1,         SEQ1);
    SECTION1.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);

    SECTION2 = createSection("section2", 16, 32);
    SECTION2.Add(PIANO, SEQ1,         SEQ1);
    SECTION2.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);
    //SECTION2.Add(SYNTH, NULL_SEQ, ALGO_SEQ);
}

public override void step()
{
    if(tick == 0 && tock == 0 && _local)
    {
        sendPatch(PIANO, AcousticGrandPiano);
        sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Lead1Square);
        sendPatch(DRUMS, 32);
    }

    //sequenced();
    randish();
}

void sequenced()
{
    bool doTick = false;

    switch(tock)
    {
        case 0:
            doTick = true;
            break;

        case 8:
        case 16:
        case 24:
        //case 32:
            double sn = _scaleNotes[_noteNum++ % _scaleNotes.Count()];
            sendNote(PIANO, sn + tick % 24, 0.7, 0.28);
            break;

        default:
            break;
    }

    if(doTick)
    {
        // keys
        switch(tick % 16)
        {
            case 0:
            case 4:
            case 8:
            case 12:
                //sendSequence(PIANO, SEQ1);
                foreach(int n in _chordNotes)
                {
                    sendNote(PIANO, n, 0.7, 1.0);
                }
                break;
        }

        // bass
        switch(tick % 16)
        {
            case 0:
            case 7:
            case 8:
                sendNote(BASS, 50, 0.8, 2.0);
                break;
        }
    }
}

void randish()
{
    // from boids:
    if(tock % 4 == 0 && random(7) == 0) // play with these for how often
    {
        int which = random(40, 80);

        if(_notesPlaying[which] == 0) // don't play if already playing
        {
            int dur = random(1, 8);
            _notesPlaying[which] = tick + dur;
            sendNote(PIANO, which, random(0.6, 0.9), dur);
        }

        // Remove any scheduled to stop now.
        for(int i = 0;i < _notesPlaying.Length;i++)
        {
            if(_notesPlaying[i] != 0 && _notesPlaying[i] == tick)
            {
                _notesPlaying[i] = 0;
            }
        }
    }
}

public void On_BACK_COLOR()
{
    //print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}

public void On_CTL2()
{
    // 0 -> 127 in
    int newval = (int)map(CTL2.Value, 0, 127, 0, 16383);
    //print("On_CTL2:", newval);
    sendController(SYNTH, PitchControl, newval);
}

public void On_CTL3()
{
    //print("On_CTL3:", CTL3.Value);
    if(random(0, 10) == 0)
    {
        sendNote(PIANO, 50 + CTL3.Value % 20, 0.7, 2.0);
    }
}

public void On_MOD1()
{
    //print(MOD1.Name, "changed to", MOD1.Value);
    // Send a controller change.
    sendController(SYNTH, Modulation, MOD1.Value);
}

public void On_VKBD_NOTE()
{
    //print("VKBD_NOTE", "=", VKBD_NOTE.Value);

    // Test for note on or off.
    if(VKBD_NOTE.Value > 0)
    {
        sendNoteOn(SYNTH, VKBD_NOTE.Value, 0.9);
    }
    else
    {
        sendNoteOff(SYNTH, -VKBD_NOTE.Value);
    }
}

public void On_KBD_NOTE()
{
    //print("KBD_NOTE", "=", KBD_NOTE.Value);

    // Test for note on or off.
    if(KBD_NOTE.Value > 0)
    {
        //sendNoteOn(PIANO, KBD_NOTE.Value, 0.9);
        sendNoteOn(SYNTH, KBD_NOTE.Value, 0.9);
        //sendNote(SYNTH, KBD_NOTE.Value, 0.8, 2.0); // fixed duration
    }
    else
    {
        //sendNoteOff(PIANO, -KBD_NOTE.Value);
        sendNoteOff(SYNTH, -KBD_NOTE.Value);
    }
}


////////////// processing stuff ////////////////////

public override void setup()
{
    // size(200, 400);
    size(500, 500);

    colorMode(HSB, 360, 100, 100);
    noStroke(); // draw no lines
    frameRate(2);

    BACK_COLOR.Value = 100;
}

public override void keyPressed()
{
    print("keyPressed:", key);
    // size(500, 500);
}

public override void draw()
{
    // drawFan();
    drawTargets();
}

void drawFan()
{
    noStroke();
    colorMode(HSB, 360, width, height);
    background(160); // gray

    double angleStep = 360 / _segmentCount;

    for (double angle = 0; angle <= 360; angle += angleStep)
    {
        fill(angle, mouseX % width, mouseY % height);

        beginShape();  // (TRIANGLE_FAN);
        vertex(width / 2, height / 2); // center

        double vx = width / 2 + cos(radians(angle)) * _radius;
        double vy = height / 2 + sin(radians(angle)) * _radius;
        vertex(vx, vy);
        
        vx -= 10;
        vy -= 10;
        vertex(vx, vy);
    
        endShape(CLOSE);
    }
}

void drawTargets()
{
    //print("draw");
    background(BACK_COLOR.Value, 100, 200);

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

void drawTarget(double xloc, double yloc, int size, int num)
{
    int grayvalues = 255 / num;
    double steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, 0 % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendNote(SYNTH, sn, 0.8, 0.48);
}

// Recursive rendering.
void drawRecursive(double x, double y, double squareSize, double minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
