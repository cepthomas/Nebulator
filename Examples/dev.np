
///// Tester for development features.

// My akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.

// Support microtonal notes with Pitch changes.
// Pitch Bend Range can be set by sending MIDI controller messages. Specifically, you do it with Registered Parameters (cc# 100 and 101).
// On the MIDI channel in question, you need to send:
// MIDI cc101  = 0
// MIDI cc100  = 0
// MIDI cc6    = value of desired bend range (in semitones)
// Example: Lets say you want to set the bend range to 2 semi-tones. First you send cc# 100 with a value of 0; then cc#101 with a value of 0. This turns on reception for setting pitch bend with the Data controller (#6). Then you send cc# 6 with a value of 2 (in semitones; this will give you a whole step up and a whole step down from the center).
// Once you have set the bend range the way you want, then you send controller 100 or 101 with a value of 127 so that any further messages of controller 6 (which you might be using for other stuff) won't change the bend range.


// Import other stuff.
$load "scale.np";

// All the neb variables.
NVariable COL1;
NVariable KPITCH;
NVariable MOD1;
NVariable KNOTE;

// All the channels.
NChannel KEYS;
NChannel SYNTH;
NChannel DRUMS;

// All the sequences
NSequence SEQ1;
NSequence DRUMS_SIMPLE;

// Sections.
NSection PART1;

// Neb script stuff.
int[] _chordNotes;
int[] _scaleNotes;
int[] _notesPlaying = new int[128];
Scale _scale;
int _c = 1;

float _ypos = 0;
int _tileCountX = 10;
int _tileCountY = 10;
int _tileWidth = 0;
int _tileHeight = 0;

public override void setupNeb()
{
    const int WHEN1 = 8;

    // All the neb variables.
    COL1 = createVariable("color", 200, 0, 255, On_COL1);
    KPITCH = createVariable("pitch", 8192, 0, 16383); // center is 8192
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KNOTE = createVariable("note", 60, -127, 127, On_KNOTE);

    // All the channels.
    KEYS = createChannel("keys", 1, 5);
    SYNTH = createChannel("synth", 3, 0);
    DRUMS = createChannel("drums", 10, 4);

    // create set of notes (chord)
    createNotes("MY_CHORD", "1 4 6 b13");
    createNotes("MY_SCALE", "1 3 4 b7");

    // controller points
    createControllerIn(KEYS, 4, COL1);
    createControllerIn(KEYS, PitchControl, KPITCH);
    createControllerIn(KEYS, NoteControl, KNOTE);

    // levers
    createLever(COL1);
    createLever(KPITCH);
    createLever(MOD1);

    // Create sequences, add notes/chords/funcs.
    SEQ1 = createSequence(8);
    SEQ1.Add(00.00, "G3", 90, 0.60);
    SEQ1.Add(01.00, "D3", 90, 0.60);
    SEQ1.Add(02.00, "A3.m7", 90, 0.60);
    SEQ1.Add(03.00, 66, 90, 0.60);
    SEQ1.Add(03.48, CrashCymbal1, 90, 0.60);

    DRUMS_SIMPLE = createSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 90);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare, 80);
    DRUMS_SIMPLE.Add("------xx------xx------xx------xx", ClosedHiHat, 100);

    // section
    NSection PART1 = createSection("section", WHEN1, 0);
    PART1.Add(KEYS, SEQ1, SEQ1);
    PART1.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);

    // Get some stock chords and scales
    _chordNotes = getNotes("C4.o7");
    _scaleNotes = getScaleNotes("Algerian", "A3");

    _scale = new Scale("Algerian", "C4", 0, 0);
    // 1 2 b3 #4 5 b6 7
    _scale.setWeight(0, 50);
    _scale.setWeight(4, 50);
    _scale.setWeight(2, 30);

    if(winGm)
    {
        sendPatch(KEYS, AcousticGrandPiano);
        //sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Pad3Polysynth);
    }
}

public override void setup()
{
    size(800, 800);
    colorMode(HSB, 360, 100, 100);
    noStroke(); // this makes the lines go away
    frameRate(1);

    COL1.Value = 100;

    _tileWidth = width / _tileCountX;
    _tileHeight = height / _tileCountY;
    noFill();
    stroke(0, 128);
}

public override void step()
{
    // if(tick == 5)
    // {
    //     speed = 50;
    //     volume = 50;
    // }

    if(tock == 0)
    {
        algoDynamic();
        //algoSequences();
    }
}

void algoDynamic()
{
    int n = _scale.randomNote();
    sendNote(SYNTH, n, 90, 0.48);
}

void algoSequences()
{
    // if(tick % 9 == 0)
    // {
    //     playSequence(KEYS, SEQ1);
    // }

    // if(tick % 13 == 0)
    // {
    //     playSequence(KEYS, SEQ2);
    // }
}

public override void keyPressed()
{
    print("keyPressed:", key);
}

public void On_COL1()
{
    print(COL1.Name, "changed to", COL1.Value);
}

public void On_MOD1()
{
    print(MOD1.Name, "changed to", MOD1.Value);

    // Send a control change.
    sendController(KEYS, 1, MOD1.Value);
}

public void On_KNOTE()
{
    print("KNOTE = ", KNOTE.Value);
}

public override void draw()
{
    //print("draw");
    background(COL1.Value, 100, 200);

    // Recursive:
    // strokeWeight(1);
    // drawRecursive(0, 0, width / 2, 1);
    // return;

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    // if (mouseIsPressed)
    // {
    //     //print("mouse is pressed");
    //     fill(random(255), random(255), random(255));
    //     strokeWeight(2);
    //     stroke(0, 100);
    //     ellipse(mouseX, mouseY, 80, 80);
    // }
}

void drawTarget(float xloc, float yloc, int size, int num)
{
    int grayvalues = 255 / num;
    float steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, (_c * 1) % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendNote(SYNTH, sn, 90, 0.48);
}

// Recursive rendering.
void drawRecursive(float x, float y, float squareSize, float minSize)
{
    rect(x, y, squareSize, squareSize);
    rect(x + squareSize, y, squareSize, squareSize);
    rect(x, y + squareSize, squareSize, squareSize);
    
    if (squareSize > minSize)
    {
        drawRecursive(x, y, squareSize / 2, minSize);
        drawRecursive(x + squareSize, y, squareSize / 2, minSize);
        drawRecursive(x, y + squareSize, squareSize / 2, minSize);
    }
}
