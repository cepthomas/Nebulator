

// IO devices.
string MY_OSC_OUT = "OSC:localhost:6449";  // 192.168.1.6:1234
string MY_OSC_IN = "OSC:6448";
string MY_VKEY = "Virtual Keyboard";


// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable VKBD_NOTE;
NVariable CTL2;
NVariable CTL3;

// All the output channels.
NChannel PIANO;
NChannel BASS;
NChannel SYNTH;
NChannel DRUMS;



public override void setupNeb()
{
    // Use wingm and virtual kbd only.
    bool local = true;

    // All the neb variables.
    CTL2 = createVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = createVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = createVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    VKBD_NOTE = createVariable("note", 60, -127, 127, On_VKBD_NOTE);

    createController(MY_VKEY, 0, NoteControl, VKBD_NOTE);

    createController(MY_OSC_IN, 1, 1, MOD1); // modulate eq
    createController(MY_OSC_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
    createController(MY_OSC_IN, 1, 3, CTL3); // another controller
    createController(MY_OSC_IN, 0, 4, BACK_COLOR); // change ui color

    // All the output channels.
    PIANO = createChannel("piano", MY_OSC_OUT, 1, 5);
    BASS = createChannel("bass", MY_OSC_OUT, 2, 4);
    SYNTH = createChannel("synth", MY_OSC_OUT, 3, 0);
    DRUMS = createChannel("drums", MY_OSC_OUT, 10, 4);

    // levers
    createLever(BACK_COLOR);
    createLever(MOD1);
}

public override void step()
{
    sequenced();
}

void sequenced()
{
    bool doTick = false;

    switch(tock)
    {
        case 0:
            doTick = true;
            break;

        case 8:
        case 16:
        case 24:
        //case 32:
            // int sn = _scaleNotes[_noteNum++ % _scaleNotes.Count()];
            // sendNote(SYNTH, sn + tick % 24, 90, 0.28);
            sendNote(SYNTH, 50 + tick % 24, 90, 0.28);
            break;

        default:
            break;
    }

    if(doTick)
    {
        // keys
        switch(tick % 16)
        {
            case 0:
            case 4:
            case 8:
            case 12:
                //sendSequence(PIANO, SEQ1);
                // foreach(int n in _chordNotes)
                // {
                //     sendNote(PIANO, n, 90, 1.0);
                // }
                break;
        }

        // bass
        switch(tick % 16)
        {
            case 0:
            case 7:
            case 8:
                sendNote(BASS, 50, 90, 2.0);
                break;
        }
    }
}

public void On_BACK_COLOR()
{
    //print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}

public void On_CTL2()
{
    // 0 -> 127 in
    int newval = (int)map(CTL2.Value, 0, 127, 0, 16383);
    //print("On_CTL2:", newval);
    sendController(SYNTH, PitchControl, newval);
}

public void On_CTL3()
{
    //print("On_CTL3:", CTL3.Value);
    if(random(0, 10) == 0)
    {
        sendNote(PIANO, 50 + CTL3.Value % 20, 90, 2.0);
    }
}

public void On_MOD1()
{
    //print(MOD1.Name, "changed to", MOD1.Value);
    // Send a control change.
    sendController(SYNTH, 1, MOD1.Value);
}

public void On_VKBD_NOTE()
{
    //print("VKBD_NOTE", "=", VKBD_NOTE.Value);

    // Test for note on or off.
    if(VKBD_NOTE.Value > 0)
    {
        sendNoteOn(SYNTH, VKBD_NOTE.Value, 110);
    }
    else
    {
        sendNoteOff(SYNTH, -VKBD_NOTE.Value);
    }
}

////////////// processing stuff ////////////////////

public override void setup()
{
    // size(200, 400);
    size(500, 500);

    colorMode(HSB, 360, 100, 100);
    noStroke(); // draw no lines
    frameRate(2);

    BACK_COLOR.Value = 100;
}

public override void keyPressed()
{
    print("keyPressed:", key);
    // size(500, 500);
}

public override void draw()
{
    drawFan();
    //drawTargets();
}

void drawFan()
{
    noStroke();
    colorMode(HSB, 360, width, height);
    background(160); // gray

    float angleStep = 360 / 12; // _segmentCount;
    int radius = 300;


    for (float angle = 0; angle <= 360; angle += angleStep)
    {
        fill(angle, mouseX % width, mouseY % height);

        beginShape();  // (TRIANGLE_FAN);
        vertex(width / 2, height / 2); // center

        float vx = width / 2 + cos(radians(angle)) * radius;
        float vy = height / 2 + sin(radians(angle)) * radius;
        vertex(vx, vy);
        
        vx -= 10;
        vy -= 10;
        vertex(vx, vy);
    
        endShape(CLOSE);
    }
}

public override void mouseClicked()
{
    // Note selected based on mouse position.
    int sn = (int)map(mouseX, 0, width, 55, 70);
    sendNote(SYNTH, sn, 90, 0.48);
}
