
// Akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.

// IO devices.
string MY_VKEY = "VKEY:";
string MY_MIDI_IN = "MIDI:MPK mini";
string MY_SYNTH_OUT = "SYNTH:ASIO4ALL v2";


// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable KBD_NOTE;
NVariable VKBD_NOTE;
NVariable CTL2;
NVariable CTL3;

// All the output channels.
NChannel SYNTH_1;

// Use win gm and virtual kbd.
bool _local = true;


// The overall synthesizer.
public class MySynth : UGen2
{
    public Voicer vcr1 = new Voicer(typeof(MyVoice), 5) { DecayTime = 0.2, Volume = 0.8 };
    public LPF lpf = new LPF() { Freq = 600, Volume = 0.8 };
    public Pan pan = new Pan() { Location = 0.0, Volume = 0.8 };
    ADSR adsrF = new ADSR() { AttackTime = 111, DecayTime = 111, SustainLevel = 111, ReleaseTime = 111, Volume = 0.8 };

    public override Sample Next(double _)
    {
        double dd = vcr1.Next(0);
        dd = lpf.Next(dd);
        Sample dout = pan.Next(dd);
        return dout;
    }

    public override void Note(double notenum, double amplitude)
    {
        // Pass along to the noisemakers.
        vcr1.Note(notenum, amplitude);
    }
}

// A single voice in the generator.
public class MyVoice : UGen
{
    // 2 oscs slightly detuned and synced
    public PulseOsc osc1 = new PulseOsc() { Freq = 400, Width = 0.1, Volume = 0.8 };
    public PulseOsc osc2 = new PulseOsc() { Freq = 420, Width = 0.1, Volume = 0.8 };
    public Mix mix1 = new Mix() { Volume = 0.8 };
    public ADSR adsr = new ADSR() { AttackTime = 0.2, DecayTime = 0.2, SustainLevel = 0.7, ReleaseTime = 0.5, Volume = 0.8 };

    public MyVoice()
    {
    }

    public override void Note(double notenum, double amplitude)
    {
        osc1.Note(notenum, amplitude);
        osc2.Note(notenum * 1.05, amplitude);
        adsr.Key(amplitude > 0);
    }

    public override double Next(double _)
    {
        double dout = adsr.Next(mix1.Next(osc1.Next(0), osc2.Next(0)));
        return dout;
    }
}

// The topmost.
MySynth syn = new MySynth();


public void On_KBD_NOTE()
{
    // Test for note on or off.
    syn.Note(KBD_NOTE.Value, KBD_NOTE.Value > 0 ? 0.9 : 0.0);
}

public void On_VKBD_NOTE()
{
    // Test for note on or off.
    syn.Note(VKBD_NOTE.Value, VKBD_NOTE.Value > 0 ? 0.9 : 0.0);
}

public void On_MOD1()
{
    syn.lpf.Freq = MOD1.Value;
}

public void On_CTL3()
{
    if(random(0, 10) == 0)
    {
        syn.Note(50 + CTL3.Value % 20, 0.7);
    }
}

public void On_CTL2()
{

}


//////////////////////////////////////////////////////
/////////////////// nebulator stuff //////////////////
//////////////////////////////////////////////////////

public override void setupNeb()
{
    // All the neb variables.
    CTL2 = createVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = createVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = createVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KBD_NOTE = createVariable("note", 60, -127, 127, On_KBD_NOTE); // note neg number for note off encoding
    VKBD_NOTE = createVariable("note", 60, -127, 127, On_VKBD_NOTE);

    // All the output channels.
    SYNTH_1 = createChannel("syn", MY_SYNTH_OUT, 1, syn);
    setWobbler(SYNTH_1, 0.2);

    if(_local)
    {
        createController(MY_VKEY, 0, NoteControl, VKBD_NOTE);
    }
    else
    {
        createController(MY_MIDI_IN, 1, 1, MOD1); // modulate eq
        createController(MY_MIDI_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
        createController(MY_MIDI_IN, 1, 3, CTL3); // another controller
        createController(MY_MIDI_IN, 0, 4, BACK_COLOR); // change ui color
        createController(MY_MIDI_IN, 1, NoteControl, KBD_NOTE); // noteOn/Off
    }

    // levers
    createLever(BACK_COLOR);
    createLever(MOD1);
}

public override void setupNeb2()
{
    // Post device creation.
}

public override void step()
{
    // if(tock % 4 == 0 && random(7) == 0) // play with these for how often
    // {
    //     int notenum = random(40, 80);
    //     int dur = random(1, 8);
    //     syn.Note(notenum, random(0.6, 0.9));
    // }
}

public void On_BACK_COLOR()
{
    //print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}



//////////////////////////////////////////////////////
////////////////// processing stuff //////////////////
//////////////////////////////////////////////////////

public override void setup()
{
    int s = 400;
    size(s, s);

    colorMode(HSB, 360, 100, 100);
    noStroke(); // draw no lines
    frameRate(2);

    BACK_COLOR.Value = 100;
}

public override void draw()
{
    // drawFan();
    drawTargets();
}

void drawFan()
{
    noStroke();
    colorMode(HSB, 360, width, height);
    background(160); // gray

    double angleStep = 10;
    int radius = 300;

    for (double angle = 0; angle <= 360; angle += angleStep)
    {
        fill(angle, mouseX % width, mouseY % height);

        beginShape();  // (TRIANGLE_FAN);
        vertex(width / 2, height / 2); // center

        double vx = width / 2 + cos(radians(angle)) * radius;
        double vy = height / 2 + sin(radians(angle)) * radius;
        vertex(vx, vy);
        
        vx -= 10;
        vy -= 10;
        vertex(vx, vy);
    
        endShape(CLOSE);
    }
}

void drawTargets()
{
    //print("draw");
    background(BACK_COLOR.Value, 100, 200);

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

void drawTarget(double xloc, double yloc, int size, int num)
{
    int grayvalues = 255 / num;
    double steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, 0 % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}
