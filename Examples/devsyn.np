
// Akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.

// IO devices.
string MY_VKEY = "VKEY:";
string MY_MIDI_IN = "MIDI:MPK mini";
string MY_SYNTH_OUT = "SYNTH:ASIO4ALL v2";


// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable KBD_NOTE;
NVariable VKBD_NOTE;
NVariable CTL2;
NVariable CTL3;
NVariable METER1;

// All the output channels.
NChannel SYNTH_1;

// Use virtual kbd.
bool _local = true;


// The overall synthesizer.
public class MySynth : UGen
{
    public Voicer vcr1 = new Voicer(typeof(MyVoice), 5) { DecayTime = 2.0, Volume = 0.8 };
    public LPF lpf = new LPF() { Freq = 1000, Volume = 0.8 };
    public ADSR adsrF = new ADSR() { AttackTime = 0.5, DecayTime = 0.5, SustainLevel = 0.5, ReleaseTime = 0.2, Volume = 0.8 };
    public Pan pan = new Pan() { Location = 0.0, Volume = 0.8 };

    public Analyzer an1 = new Analyzer() { };

    public override Sample Next2()
    {
        double dout = vcr1.Next();
        lpf.Freq = 400 + adsrF.Next(1) * 2000;
        dout = lpf.Next(dout); //TODON2 clicks when playing many notes fast
        dout = an1.Next(dout);
        Sample sout = pan.Next2(dout);
        return sout;
    }

    public override void NoteOn(double notenum, double amplitude)
    {
        vcr1.NoteOn(notenum, amplitude);
        adsrF.KeyDown();
    }

    public override void NoteOff(double notenum)
    {
        vcr1.NoteOff(notenum);
        adsrF.KeyUp();
    }
}

// A single voice in the generator.
public class MyVoice : UGen
{
    // 2 oscs slightly detuned and synced
    public PulseOsc osc1 = new PulseOsc() { Freq = 400, Width = 0.1, Volume = 0.8 };
    public PulseOsc osc2 = new PulseOsc() { Freq = 405, Width = 0.1, Volume = 0.8 };
    public Mix mix1 = new Mix() { Volume = 0.8 };
    public ADSR adsr = new ADSR() { AttackTime = 0.2, DecayTime = 0.2, SustainLevel = 0.7, ReleaseTime = 0.2, Volume = 0.8 };

    public override void NoteOn(double notenum, double amplitude)
    {
        s.print("script MyVoice - NoteOn()");
        osc1.NoteOn(notenum, amplitude);
        osc2.NoteOn(notenum * 1.01, amplitude);
        adsr.KeyDown();
    }

    public override void NoteOff(double notenum)
    {
        s.print("script MyVoice - NoteOff()");
        // Don't actually NoteOff - let the ADSR ramp down.
        // osc1.NoteOff(notenum);
        // osc2.NoteOff(notenum * 1.05);
        adsr.KeyUp();
    }

    public override double Next()
    {
        //double dout = osc1.Next();
        double dout = adsr.Next(mix1.Next(osc1.Next(), osc2.Next()));
        return dout;
    }
}

// The topmost.
MySynth syn = new MySynth();

///// Event handlers /////
public void On_KBD_NOTE()
{
    // Test for note on or off.
    if(KBD_NOTE.Value > 0)
    {
        syn.NoteOn(KBD_NOTE.Value, 0.9);
    }
    else
    {
        syn.NoteOff(KBD_NOTE.Value);
    }
}

public void On_VKBD_NOTE()
{
    // Test for note on or off.
    if(VKBD_NOTE.Value > 0)
    {
        syn.NoteOn(VKBD_NOTE.Value, 0.9);
    }
    else
    {
        syn.NoteOff(VKBD_NOTE.Value);
    }
}

// public void On_METER1()
// {
//     syn.NoteOn(50 + METER1.Value % 20, 0.7);
// }


public void On_MOD1()
{
    syn.lpf.Freq = MOD1.Value;
}

public void On_CTL2()
{

}

public void On_CTL3()
{
    if(random(0, 10) == 0)
    {
        syn.NoteOn(50 + CTL3.Value % 20, 0.7);
    }
}

public void On_BACK_COLOR()
{
    //print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}


///// Start neb /////
public override void setupNeb()
{
    // All the neb variables.
    CTL2 = createVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = createVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = createVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KBD_NOTE = createVariable("note", 60, -127, 127, On_KBD_NOTE); // note neg number for note off encoding
    VKBD_NOTE = createVariable("note", 60, -127, 127, On_VKBD_NOTE);
    METER1 = createVariable("meter1", 0, 0, 100);//, On_METER1_NOTE);

    // All the output channels.
    SYNTH_1 = createChannel("syn", MY_SYNTH_OUT, 1, syn);
    setWobbler(SYNTH_1, 0.2);

    if(_local)
    {
        createController(MY_VKEY, 0, NoteControl, VKBD_NOTE);
    }
    else
    {
        createController(MY_MIDI_IN, 1, 1, MOD1); // modulate eq
        createController(MY_MIDI_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
        createController(MY_MIDI_IN, 1, 3, CTL3); // another controller
        createController(MY_MIDI_IN, 0, 4, BACK_COLOR); // change ui color
        createController(MY_MIDI_IN, 1, NoteControl, KBD_NOTE); // noteOn/Off
    }

    // levers
    createLever(BACK_COLOR);
    createLever(MOD1);

    // meters
//    createMeter(METER1, Linear);
}

public override void setupNeb2()
{
    // Post device creation.
}

///// Neb runtime /////
public override void step()
{
    // if(tock % 4 == 0 && random(7) == 0) // play with these for how often
    // {
    //     int notenum = random(40, 80);
    //     int dur = random(1, 8);
    //     syn.Note(notenum, random(0.6, 0.9));
    // }
}



//////////////////////////////////////////////////////
//////////////// processing UI stuff /////////////////
//////////////////////////////////////////////////////

public override void setup()
{
    int s = 400;
    size(s, s);

    colorMode(HSB, 360, 100, 100);
    noStroke(); // draw no lines
    frameRate(2);

    BACK_COLOR.Value = 100;
}

public override void draw()
{
    // drawFan();
    drawTargets();
}

void drawFan()
{
    noStroke();
    colorMode(HSB, 360, width, height);
    background(160); // gray

    double angleStep = 10;
    int radius = 300;

    for (double angle = 0; angle <= 360; angle += angleStep)
    {
        fill(angle, mouseX % width, mouseY % height);

        beginShape();  // (TRIANGLE_FAN);
        vertex(width / 2, height / 2); // center

        double vx = width / 2 + cos(radians(angle)) * radius;
        double vy = height / 2 + sin(radians(angle)) * radius;
        vertex(vx, vy);
        
        vx -= 10;
        vy -= 10;
        vertex(vx, vy);
    
        endShape(CLOSE);
    }
}

void drawTargets()
{
    //print("draw");
    background(BACK_COLOR.Value, 100, 200);

    drawTarget(width * 0.15f, height * 0.4f, 100, 10);
    drawTarget(width * 0.5f, height * 0.5f, 300, 20);
    drawTarget(width * 0.85f, height * 0.3f, 150, 12);    

    if (mouseIsPressed)
    {
        //print("mouse is pressed");
        fill(random(255), random(255), random(255));
        strokeWeight(2);
        stroke(0, 100);
        ellipse(mouseX, mouseY, 80, 80);
    }
}

void drawTarget(double xloc, double yloc, int size, int num)
{
    int grayvalues = 255 / num;
    double steps = size / num;
    for (int i = 0; i < num; i++)
    {
        fill(i * grayvalues, num * 10, 0 % 255);
        ellipse(xloc, yloc, size - i * steps, size - i * steps);
    }

    int radius = size / 2;
    int h = random(0, 360);

    for (int r = radius; r > 0; r-=1)
    {
        fill(h, 90, 90);
        ellipse(xloc, yloc, r * 2, r * 2);
        h = (h + 1) % 360;
    }
}
