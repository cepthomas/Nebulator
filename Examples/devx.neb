
// Akai kbd midi: Pad1-8 are notes 44-51, knob1-8 are controllers ctlr1-8.


// Use win gm and virtual kbd only. Otherwise all midi.
bool _minimal = true;


// All the neb variables.
NVariable BACK_COLOR;
NVariable MOD1;
NVariable KBD_NOTE;
NVariable VKBD_NOTE;
NVariable CTL2;
NVariable CTL3;

// All the output channels.
NChannel PIANO;
NChannel BASS;
NChannel SYNTH;
NChannel DRUMS;

// All the sequences
NSequence PIANO_MAIN;
NSequence DRUMS_SIMPLE;
NSequence DRUMS_VERSE;

// // Sections.
// NSection SECTION1;
// NSection SECTION2;


const double KEYS_DEF_VOL = 0.8;
const double DRUM_DEF_VOL = 0.8;


// Neb script stuff.
double[] _chordNotes;
double[] _scaleNotes;
int _noteNum = 0;

// Index is integer note number, value is when to stop it.
// int[] _notesPlaying = new int[128];

// Current playing.
string _section = "idle";

// IO device names.
string MIDI_IN = "MIDI:MPK mini";
string MIDI_OUT = "MIDI:loopMIDI Port 1";
string OSC_IN = "OSC:6448";
string OSC_OUT = "OSC:127.0.0.1:1234";
string GS_MIDI_OUT = "MIDI:Microsoft GS Wavetable Synth";


public override void setup()
{
    // All the neb variables.
    CTL2 = createVariable("ctl2", 200, 0, 255, On_CTL2);
    CTL3 = createVariable("ctl3", 200, 0, 255, On_CTL3);
    BACK_COLOR = createVariable("color", 200, 0, 255, On_BACK_COLOR);
    MOD1 = createVariable("mod", 127, 0, 255, On_MOD1);
    KBD_NOTE = createVariable("note", 60, -127, 127, On_KBD_NOTE); // note neg number for note off encoding
    VKBD_NOTE = createVariable("note", 60, -127, 127, On_VKBD_NOTE);

    // IO devices.
    if(_minimal)
    {
        // All the outputs.
        PIANO = createChannel("piano", GS_MIDI_OUT, 1);
        BASS = createChannel("bass", GS_MIDI_OUT, 2);
        SYNTH = createChannel("synth", GS_MIDI_OUT, 3);
        DRUMS = createChannel("drums", GS_MIDI_OUT, 10);

        // All the inputs.
        createController("VKEY:", 1, NoteControl, VKBD_NOTE);
    }
    else
    {
        // All the outputs.
        PIANO = createChannel("piano", MIDI_OUT, 1);
        BASS = createChannel("bass", MIDI_OUT, 2);
        SYNTH = createChannel("synth", MIDI_OUT, 3);
        DRUMS = createChannel("drums", MIDI_OUT, 10);

        // All the inputs.
        createController(MIDI_IN, 1, 1, MOD1); // modulate eq
        createController(MIDI_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
        createController(MIDI_IN, 1, 3, CTL3); // another controller
        createController(MIDI_IN, 1, 4, BACK_COLOR); // change ui color
        createController(MIDI_IN, 1, NoteControl, KBD_NOTE);
    }

    setWobbler(PIANO, 0.2);
    setWobbler(BASS, 0.1);
    setWobbler(DRUMS, 0.1);

    // createController(OSC_IN, 1, 1, MOD1); // modulate eq
    // createController(OSC_IN, 1, 2, CTL2); // since I don't have a pitch knob, I'll use this instead
    // createController(OSC_IN, 1, 3, CTL3); // another controller
    // createController(OSC_IN, 0, 4, BACK_COLOR); // change ui color


    // levers
    createLever(BACK_COLOR);
    createLever(MOD1);

    // create set of notes (chord)
    createNotes("CHORD", "1 4 6 b13");
    createNotes("SCALE", "1 3 4 b7");

    // Get some stock chords and scales
    _chordNotes = getNotes("C4.o7");
    _scaleNotes = getScaleNotes("Algerian", "A3");

    // Create sequences, add notes/chords/funcs.
    PIANO_MAIN = createSequence(8);
    PIANO_MAIN.Add(00.00, "G3", 0.7, 0.60);
    PIANO_MAIN.Add(01.00, "D3", 0.7, 0.60);
    PIANO_MAIN.Add(02.00, "A3.m7", 0.7, 0.60);
    PIANO_MAIN.Add(03.00, 66, 0.7, 0.60);
    PIANO_MAIN.Add(03.48, CrashCymbal1, 0.7, 0.60);

    DRUMS_SIMPLE = createSequence(8);
    DRUMS_SIMPLE.Add("x-------x-------x-------x-------", AcousticBassDrum, 0.7);
    DRUMS_SIMPLE.Add("----x-------x-x-----x-------x-x-", AcousticSnare, 0.6);
    DRUMS_SIMPLE.Add("------xx------xx------xx------xx", ClosedHiHat, 0.8);

    DRUMS_VERSE = createSequence(8);
    DRUMS_VERSE.Add(0.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(1.60, HiMidTom,         DRUM_DEF_VOL);
    DRUMS_VERSE.Add(2.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(3.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(4.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.00, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.10, RideCymbal1,      DRUM_DEF_VOL);
    DRUMS_VERSE.Add(5.60, HiMidTom,         DRUM_DEF_VOL);
    DRUMS_VERSE.Add(6.00, AcousticBassDrum, DRUM_DEF_VOL);
    DRUMS_VERSE.Add(7.00, CrashCymbal2,     DRUM_DEF_VOL);

    // // Sections needed?
    // SECTION1 = createSection("section1", 0, 16);
    // SECTION1.Add(PIANO, SEQ1,         SEQ1);
    // SECTION1.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);

    // SECTION2 = createSection("section2", 16, 32);
    // SECTION2.Add(PIANO, SEQ1,         SEQ1);
    // SECTION2.Add(DRUMS, DRUMS_SIMPLE, DRUMS_SIMPLE);
    // //SECTION2.Add(SYNTH, NULL_SEQ, ALGO_SEQ);
}

public override void setup2()
{
    if(_minimal)
    {
        sendPatch(PIANO, AcousticGrandPiano);
        sendPatch(BASS, AcousticBass);
        sendPatch(SYNTH, Lead1Square);
        sendPatch(DRUMS, 32);
    }
}




public override void step()
{
    if(tock != 0) // not looking at tocks right now
    {
        return;
    }

    // doState();
    switch(tick)
    {
        case 0:  _section = "part1"; break;
        case 16: _section = "part2"; break;
        case 32: _section = "part3"; break;
        case 48: _section = "end";   break;
        case 52: _section = "idle";  break;
        default: /* no change */     break;
    }

    // Sequence size in ticks.
    int NSEQ = 8;
    // Total size in ticks.
    int NTOT = NSEQ * 4;


    ///// drums /////
    if(isOneOf(tick, 0, 8, 24))
    {
        sendSequence(DRUMS, DRUMS_SIMPLE);
    }

    if(isOneOf(tick, 16))
    {
        sendSequence(DRUMS, DRUMS_VERSE);
    }

    ///// piano /////
    if(isOneOf(tick, 0, 8, 16))
    {
        sendSequence(PIANO, PIANO_MAIN);
    }

    if(isOneOf(tick, 26))
    {
        double sn = _scaleNotes[_noteNum++ % _scaleNotes.Count()];
        sendNote(PIANO, sn + tick % 24, 0.7, 0.28);

        // foreach(int n in _chordNotes)
        // {
        //     sendNote(PIANO, n, 0.7, 1.0);
        // }
    }

    ///// bass /////
    if(isOneOf(tick % 16, 0, 7, 8))
    {
        sendNote(BASS, 50, 0.8, 2.0);
    }
}

public void On_BACK_COLOR()
{
    //print(BACK_COLOR.Name, "changed to", BACK_COLOR.Value);
}

public void On_CTL2()
{
    // 0 -> 127 in
    int newval = (int)Utils.Map(CTL2.Value, 0, 127, 0, 16383);
    //print("On_CTL2:", newval);
    sendController(SYNTH, PitchControl, newval);
}

public void On_CTL3()
{
    //print("On_CTL3:", CTL3.Value);
    if(random(0, 10) == 0)
    {
        sendNote(PIANO, 50 + CTL3.Value % 20, 0.7, 2.0);
    }
}

public void On_MOD1()
{
    //print(MOD1.Name, "changed to", MOD1.Value);
    // Send a controller change.
    sendController(SYNTH, Modulation, MOD1.Value);
}

public void On_VKBD_NOTE()
{
    //print("VKBD_NOTE", "=", VKBD_NOTE.Value);

    // Test for note on or off.
    if(VKBD_NOTE.Value > 0)
    {
        sendNoteOn(SYNTH, VKBD_NOTE.Value, 0.9);
    }
    else
    {
        sendNoteOff(SYNTH, -VKBD_NOTE.Value);
    }
}

public void On_KBD_NOTE()
{
    //print("KBD_NOTE", "=", KBD_NOTE.Value);

    // Test for note on or off.
    if(KBD_NOTE.Value > 0)
    {
        //sendNoteOn(PIANO, KBD_NOTE.Value, 0.9);
        sendNoteOn(SYNTH, KBD_NOTE.Value, 0.9);
        //sendNote(SYNTH, KBD_NOTE.Value, 0.8, 2.0); // fixed duration
    }
    else
    {
        //sendNoteOff(PIANO, -KBD_NOTE.Value);
        sendNoteOff(SYNTH, -KBD_NOTE.Value);
    }
}
