using System;
using System.Collections.Generic;
using System.Linq;
using Nebulator.Common;


namespace Nebulator.Midi
{
    /// <summary>
    /// Base class for internal interface representation of a compiled event to be sent as midi.
    /// It has some extra functionality not supported by the NAudio MidiEvent.
    /// </summary>
    public abstract class Step
    {
        ///// <summary>For use by client/owner.</summary>
        public object Tag { get; set; } = null;

        /// <summary>Channel.</summary>
        public int Channel { get; set; } = 1;

        /// <summary>
        /// Possibly make adjustments to values.
        /// </summary>
        public virtual void Adjust(int trackVolume, int modulate)
        {
        }

        /// <summary>For viewing pleasure.</summary>
        public override string ToString()
        {
            return $"Channel:{Channel}";
        }
    }

    public class StepNoteOn : Step
    {
        /// <summary>The default note.</summary>
        public int NoteNumber { get; set; } = 60;

        /// <summary>The possibly modified NoteNumber.</summary>
        public int NoteNumberToPlay { get; set; } = 60;

        /// <summary>The default volume.</summary>
        public int Velocity { get; set; } = 90;

        /// <summary>The possibly modified Volume.</summary>
        public int VelocityToPlay { get; set; } = 90;

        /// <summary>Time between note on/off in Tocks. TODO or Time? Default of 0 indicates note off generated by owner.</summary>
        public int Duration { get; set; } = 0;

        /// <summary>
        /// Possibly make adjustments to values.
        /// </summary>
        public override void Adjust(int trackVolume, int modulate)
        {
            // Maybe alter note velocity.
            int masterVolume = Globals.CurrentPersisted.Volume;
            int vel = Velocity * trackVolume * masterVolume / MidiInterface.MAX_MIDI_VOLUME / MidiInterface.MAX_MIDI_VOLUME;
            VelocityToPlay = Utils.Constrain(vel, 0, MidiInterface.MAX_MIDI_VOLUME);

            // Maybe alter note number.
            NoteNumberToPlay = Utils.Constrain(NoteNumber + modulate, 0, MidiInterface.MAX_MIDI_NOTE);
        }

        /// <summary>For viewing pleasure.</summary>
        public override string ToString()
        {
            return $"StepNoteOn: {base.ToString()} NoteNumberToPlay:{NoteNumberToPlay} VelocityToPlay:{VelocityToPlay}";
        }
    }

    public class StepNoteOff : Step
    {
        /// <summary>The default note.</summary>
        public int NoteNumber { get; set; } = 60;

        /// <summary>The possibly modified NoteNumber.</summary>
        public int NoteNumberToPlay { get; set; } = 60;

        /// <summary>Velocity.</summary>
        public int Velocity { get; set; } = 64; // seems to be standard default.

        /// <summary>When it's done in msec - used by stop note tracking.</summary>
        public int Expiry { get; set; } = -1;

        /// <summary>Constructor to make a deferred note off from a note on.</summary>
        /// <param name="step"></param>
        public StepNoteOff(StepNoteOn step)
        {
            Tag = step.Tag;
            Channel = step.Channel;
            NoteNumber = Utils.Constrain(step.NoteNumber, 0, MidiInterface.MAX_MIDI_NOTE);
            NoteNumberToPlay = step.NoteNumberToPlay;
            Expiry = step.Duration;
        }

        /// <summary>Default constructor.</summary>
        public StepNoteOff()
        {
        }

        /// <summary>
        /// Possibly make adjustments to values.
        /// </summary>
        public override void Adjust(int trackVolume, int modulate)
        {
            // Maybe alter note number.
            NoteNumberToPlay = Utils.Constrain(NoteNumber + modulate, 0, MidiInterface.MAX_MIDI_NOTE);
        }

        /// <summary>For viewing pleasure.</summary>
        public override string ToString()
        {
            return $"StepNoteOff: {base.ToString()} NoteNumberToPlay:{NoteNumberToPlay}";
        }
    }

    public class StepControllerChange : Step
    {
        /// <summary>Specific controller.</summary>
        public int MidiController { get; set; } = MidiInterface.CTRL_NONE;

        /// <summary>The midi payload. Also used for Pitch.</summary>
        public int ControllerValue { get; set; } = 0;

        /// <summary>For viewing pleasure.</summary>
        public override string ToString()
        {
            return $"StepControllerChange: {base.ToString()} Controller:{ControllerValue}";
        }
    }

    public class StepPatch : Step
    {
        /// <summary>Specific patch.</summary>
        public int PatchNumber { get; set; } = 0;

        /// <summary>For viewing pleasure.</summary>
        public override string ToString()
        {
            return $"StepPatchChange: {base.ToString()} PatchNumber:{PatchNumber}";
        }
    }


    /// <summary>A collection of Steps.</summary>
    public class StepCollection // TODO still useful?
    {
        ///<summary>The main collection of Steps. The key is the time to send the list.</summary>
        Dictionary<Time, List<Step>> _steps = new Dictionary<Time, List<Step>>();

        #region Properties
        ///<summary>Gets a collection of the list.</summary>
        public IEnumerable<Time> Times
        {
            get { return (_steps.Keys); }
        }

        ///<summary>Gets the count property of the list.</summary> use Times.Count
        public int Count
        {
            get { return _steps.Count; }
        }

        ///<summary>The duration of the whole thing.</summary>
        public int MaxTick { get; private set; } = 0;
        #endregion

        #region Functions
        /// <summary>
        /// Add a step at the given time.
        /// </summary>
        /// <param name="time"></param>
        /// <param name="step"></param>
        public void AddStep(Time time, Step step)
        {
            if (!_steps.ContainsKey(time))
            {
                _steps.Add(time, new List<Step>());
            }
            _steps[time].Add(step);

            MaxTick = Math.Max(MaxTick, time.Tick);
        }

        /// <summary>
        /// Get the steps for the given time.
        /// </summary>
        public IEnumerable<Step> GetSteps(Time time)
        {
            return _steps.ContainsKey(time) ? _steps[time] : new List<Step>();
            //return GetSteps(time);
        }

        /// <summary>
        /// Cleanse me.
        /// </summary>
        public void Clear()
        {
            _steps.Clear();
        }

        /// <summary>
        /// Display the content steps.
        /// </summary>
        public override string ToString()
        {
            int total = 0;
            foreach(IList<Step> steps in _steps.Values)
            {
                total += steps.Count;
            }
            return $"Count:{Count} Total:{total}";

            //List<string> ls = new List<string>();
            //Times.ToList().ForEach(t => ls.Add(new Time(t).ToString()));
            //return string.Join(", ", ls);

            //List<int> ticktocks = Times.ToList();
            //ticktocks.Sort();
            //foreach (int i in ticktocks)
            //{
            //    Time t = new Time() { Packed = i };
            //    ls.AppendFormat("Time:{0}{1}", t, Environment.NewLine);
            //    _steps[i].ForEach(x => ls.AppendFormat("  {0}{1}", x, Environment.NewLine));
            //}
        }
        #endregion
    }
    
}
