using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using NAudio.Midi;
using NLog;
using Nebulator.Common;


namespace Nebulator.Midi
{
    /// <summary>Reads in and processes standard yahama style files.</summary>
    public class StyleParser
    {
        #region Properties
        /// <summary>All the part names.</summary>
        public List<string> Parts { get { return _parts.ToList(); } }

        /// <summary>All the channel numbers.</summary>
        public List<int> Channels { get { return _channels.ToList(); } }

        /// <summary>Resolution for all events.</summary>
        public int DeltaTicksPerQuarterNote { get; private set; } = 0;

        /// <summary>Tempo, if supplied by file.</summary>
        public double Tempo { get; private set; } = 0.0;

        /// <summary>Time signature, if supplied by file.</summary>
        public string TimeSig { get; private set; } = "";

        /// <summary>Key signature, if supplied by file.</summary>
        public string KeySig { get; private set; } = "";

        /// <summary>Fixed value.</summary>
        public int MidiFileType { get; } = 0;

        /// <summary>Fixed value.</summary>
        public int Tracks { get; } = 1;
        #endregion

        #region Fields
        /// <summary>All the events - key is part/channel.</summary>
        Dictionary<(string part, int channel), List<MidiEvent>> _events = new Dictionary<(string, int), List<MidiEvent>>();

        /// <summary>Name of current part being processed.</summary>
        string _currentPart = "";

        /// <summary>Backing value.</summary>
        HashSet<string> _parts = new HashSet<string>();

        /// <summary>Backing value.</summary>
        HashSet<int> _channels = new HashSet<int>();
        #endregion

        #region Public functions
        /// <summary>
        /// Read a style file. For style parsing, only a minimal set is included. You can add the rest.
        /// See http://www.wierzba.homepage.t-online.de/StyleFileDescription_v21.pdf.
        /// </summary>
        /// <param name="fileName"></param>
        public void ProcessFile(string fileName)
        {
            // Init everything.
            _events.Clear();
            _parts.Clear();
            _channels.Clear();
            DeltaTicksPerQuarterNote = 0;
            Tempo = 0.0;
            TimeSig = "";
            KeySig = "";

            using (var br = new BinaryReader(File.OpenRead(fileName)))
            {
                bool done = false;
                uint chunkSize = 0;

                while (!done)
                {
                    string chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));

                    switch (chunkHeader)
                    {
                        case "MThd":
                            // Midi section.
                            ReadMidiSection(br);
                            break;

                        case "CASM":
                            // The information in the CASM section is necessary if the midi section does not follow the rules
                            // for “simple” style files, which do not necessarily need a CASM section (see chapter 5.2.1 for
                            // the rules). The CASM section gives instructions to the instrument on how to deal with the midi data.
                            // This includes:
                            // - Assigning the sixteen possible midi channels to 8 accompaniment channels which are
                            //   available to a style in the instrument (9 = sub rhythm, 10 = rhythm, 11 = bass, 12 = chord 1,
                            //   13 = chord 2, 14 = pad, 15 = phrase 1, 16 = phrase 2). More than one midi channel
                            //   may be assigned to an accompaniment channel.
                            // - Allowing the PSR to edit the source channel in StyleCreator. This setting is overridden by
                            //   the instrument if the style has > 1 midi source channel assigned to an accompaniment
                            //   channel. In this case the source channels are not editable.
                            // - Muting/enabling specific notes or chords to trigger the accompaniment. In practice, only
                            //   chord choices are used.
                            // - The key that is used in the midi channel. Styles often use different keys for the midi data.
                            //   Styles without a CASM must be in the key of CMaj7.
                            // - How the chords and notes are transposed as chords are changed and how notes held
                            //   through chord changes are reproduced.
                            // - The range of notes generated by the style.
                            chunkSize = Utils.SwapUInt32(br.ReadUInt32());
                            break;

                        case "CSEG":
                            chunkSize = Utils.SwapUInt32(br.ReadUInt32());
                            break;

                        case "Sdec":
                            chunkSize = Utils.SwapUInt32(br.ReadUInt32());
                            // swallow for now
                            br.ReadBytes((int)chunkSize);
                            break;

                        case "Ctab":
                            // Has some key and chord info.
                            chunkSize = Utils.SwapUInt32(br.ReadUInt32());
                            // swallow for now
                            br.ReadBytes((int)chunkSize);
                            break;

                        case "Cntt":
                            chunkSize = Utils.SwapUInt32(br.ReadUInt32());
                            // swallow for now
                            br.ReadBytes((int)chunkSize);
                            break;

                        default:
                            // ignore the rest.
                            done = true;
                            break;
                    }
                }
            }
        }

        /// <summary>
        /// Helper to get an event collection.
        /// </summary>
        /// <param name="part"></param>
        /// <param name="channel"></param>
        /// <returns>The collection or null if invalid.</returns>
        public IList<MidiEvent> GetEvents(string part, int channel)
        {
            _events.TryGetValue((part, channel), out List<MidiEvent> ret);
            return ret;
        }
        #endregion

        #region Private functions
        /// <summary>
        /// Read the midi section of a style file.
        /// </summary>
        /// <param name="br"></param>
        void ReadMidiSection(BinaryReader br)
        {
            // Current note on events, looking for corresponding note offs.
            NoteOnEvent[,] ons = new NoteOnEvent[MidiInterface.NUM_MIDI_CHANNELS, MidiInterface.MAX_MIDI_NOTE];
            List<string> leftovers = new List<string>();
            int absoluteTime = 0;

            uint chunkSize = Utils.SwapUInt32(br.ReadUInt32());

            if (chunkSize != 6)
            {
                throw new FormatException("Unexpected header chunk length");
            }

            int fileFormat = Utils.SwapUInt16(br.ReadUInt16());
            int tracks = Utils.SwapUInt16(br.ReadUInt16());
            DeltaTicksPerQuarterNote = Utils.SwapUInt16(br.ReadUInt16());

            // Style midi section is always type 0 - only one track.
            if (fileFormat != 0 || tracks != 1)
            {
                throw new FormatException("Invalid file format for style");
            }

            string chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));
            if (chunkHeader != "MTrk")
            {
                throw new FormatException("Invalid chunk header");
            }

            chunkSize = Utils.SwapUInt32(br.ReadUInt32());
            long startPos = br.BaseStream.Position;

            // Read all midi events.
            MidiEvent me = null; // current

            HashSet<int> channels = new HashSet<int>();
            HashSet<int> whens = new HashSet<int>();

            List<string> parts = new List<string>();

            // MidiEvent:
            // protected MidiEvent();
            // public int DeltaTime { get; }
            // public long AbsoluteTime { get; set; }
            // public MidiCommandCode CommandCode { get; }
            // public MidiEvent(long absoluteTime, int channel, MidiCommandCode commandCode);
            // public override string ToString();
            // public static bool IsEndTrack(MidiEvent midiEvent);
            // public static bool IsNoteOff(MidiEvent midiEvent);
            // public static bool IsNoteOn(MidiEvent midiEvent);
            // public static int ReadVarInt(BinaryReader br);
            // public static MidiEvent FromRawMessage(int rawMessage);
            // public static MidiEvent ReadNextEvent(BinaryReader br, MidiEvent previous);
            // public static void WriteVarInt(BinaryWriter writer, int value);
            // public virtual int Channel { get; set; }
            // public virtual int GetAsShortMessage();
            // public virtual MidiEvent Clone();
            // public virtual void Export(ref long absoluteTime, BinaryWriter writer);

            while (br.BaseStream.Position < startPos + chunkSize)
            {
                me = MidiEvent.ReadNextEvent(br, me);
                absoluteTime += me.DeltaTime;
                me.AbsoluteTime = absoluteTime;

                switch (me.CommandCode)
                {
                    case MidiCommandCode.MetaEvent when (me as MetaEvent).MetaEventType == MetaEventType.Marker:
                        {
                            // Indicates start of a new midi part. Bin per channel.
                            _currentPart = (me as TextEvent).Text;
                            absoluteTime = 0;

                            // Clean up the note tracking. TODO leftovers?
                            ons = new NoteOnEvent[MidiInterface.NUM_MIDI_CHANNELS, MidiInterface.MAX_MIDI_NOTE];
                        }
                        break;

                    case MidiCommandCode.NoteOn:
                        {
                            // Save it while waiting for note off.
                            NoteOnEvent evt = me as NoteOnEvent;

                            // Check for dupes. TODO.
                            NoteOnEvent on = ons[evt.Channel, evt.NoteNumber];
                            if (on != null)
                            {

                            }


                            if (evt.Velocity > 0)
                            {
                                ons[evt.Channel, evt.NoteNumber] = evt;
                                //currentEvents?[0].Add(evt);
                            }
                            else
                            {
                                // It's actually an off - handle as such.
                                ons[evt.Channel, evt.NoteNumber] = null;
                            }
                        }
                        break;

                    case MidiCommandCode.NoteOff:
                        {
                            NoteEvent evt = me as NoteEvent;
                            NoteOnEvent on = ons[evt.Channel, evt.NoteNumber];
                            if (on != null)
                            {
                                AddEvent(evt);

                                // Reset it.
                                ons[evt.Channel, evt.NoteNumber] = null;
                            }
                        }
                        break;

                    case MidiCommandCode.ControlChange:
                        {
                            ControlChangeEvent evt = me as ControlChangeEvent;
                            AddEvent(evt);
                        }
                        break;

                    case MidiCommandCode.PitchWheelChange:
                        {
                            PitchWheelChangeEvent evt = me as PitchWheelChangeEvent;
                            AddEvent(evt);
                        }
                        break;

                    case MidiCommandCode.PatchChange:
                        {
                            PatchChangeEvent evt = me as PatchChangeEvent;
                            leftovers.Add(evt.ToString());
                        }
                        break;

                    case MidiCommandCode.MetaEvent when (me as MetaEvent).MetaEventType == MetaEventType.SequenceTrackName:
                        {
                            // Indicates start of a new midi track.
                            leftovers.Add(me.ToString());
                        }
                        break;

                    case MidiCommandCode.MetaEvent when (me as MetaEvent).MetaEventType == MetaEventType.EndTrack:
                        {
                            // Indicates end of current midi track.
                            leftovers.Add(me.ToString());
                        }
                        break;

                    case MidiCommandCode.MetaEvent when (me as MetaEvent).MetaEventType == MetaEventType.SetTempo:
                        {
                            TempoEvent evt = me as TempoEvent;
                            Tempo = evt.Tempo;
                        }
                        break;

                    case MidiCommandCode.MetaEvent when (me as MetaEvent).MetaEventType == MetaEventType.TimeSignature:
                        {
                            TimeSignatureEvent evt = me as TimeSignatureEvent;
                            TimeSig = evt.TimeSignature;
                        }
                        break;

                    case MidiCommandCode.MetaEvent when (me as MetaEvent).MetaEventType == MetaEventType.KeySignature:
                        {
                            KeySignatureEvent evt = me as KeySignatureEvent;
                            KeySig = evt.ToString();
                        }
                        break;

                    default:
                        leftovers.Add(me.ToString());
                        break;
                }
            }

            if (br.BaseStream.Position != startPos + chunkSize)
            {
                throw new Exception($"Read overrub error: {chunkSize}+{startPos}!={br.BaseStream.Position}");
            }
        }

        /// <summary>
        /// Helper function.
        /// </summary>
        /// <param name="evt"></param>
        void AddEvent(MidiEvent evt)
        {
            if (!_events.ContainsKey((_currentPart, evt.Channel)))
            {
                _events.Add((_currentPart, evt.Channel), new List<MidiEvent>());
                Parts.Add(_currentPart);

            }

            _events[(_currentPart, evt.Channel)].Add(evt);
        }
        #endregion
    }
}
