# What This Is

- Most music software uses piano roll midi editors. This is an alternative - writing scripts to generate sounds.
- C# makes a reasonable scripting language, given that we have the compiler available to us at run time.
- Supports midi and midi-over-OSC.
- While the primary intent is to generate music-by-code, runtime interaction is also supported using midi or OSC inputs.
- It's called Nebulator after a MarkS C++ noisemaker called Nebula which allowed manipulation of synth parameters using code.
- Requires VS2022 and .NET6.

![logo](marks.png)

## Usage

- Main window includes the transport control and one per channel controls.
- Also has log and comm tracing. Note that comm tracing has an impact on performance so use it judiciously.
- Basically open a .neb file, press compile, then run.
- Use your favorite external text editor. The application will watch for changes you make and indicate that recompile
  is needed. I use Sublime - you can associate .neb files with C# for pretty-close syntax coloring.
- Click on the settings icon to edit your devices and options.


## Example Script Files
See the Examples directory for material while perusing the docs.

File        | Description
----------- | -----------
example.neb | Source file showing example of static sequence and loop definitions, and creating notes by script functions.
airport.neb | A take on Eno's Music for Airports - adapted from [this](https://github.com/teropa/musicforairports.js).
utils.neb   | Example of a library file for simple functions.
scale.neb   | Example of a library file for playing with a scale.
*.nebp      | Storage for dynamic stuff. This is created and managed by the application and not generally manually edited.
temp\\\*.cs | Generated C# files which are compiled and executed.
example.mp3 | A bit of some generated sound (not music!) using Reaper with good instruments and lots of reverb. I like lots of reverb.
airport.mp3 | Snippet generated by airport.neb and Reaper.


## External Components

- [NAudio](https://github.com/naudio/NAudio) (Microsoft Public License).
- Application icon: [Charlotte Schmidt](http://pattedemouche.free.fr/) (Copyright Â© 2009 of Charlotte Schmidt).
- Button icons: [Glyphicons Free](http://glyphicons.com/) (CC BY 3.0).
- Markdown rendering: [Markdeep](https://casual-effects.com/markdeep).


# Script Syntax

This section describes the general structure and syntax rules of script files.  

Script functions are very C#-like because essentially it is C# (without stuff like namespaces). The compiler adds in the surrounding boilerplate and compiles the whole mess in memory where it executes.  

You can clean up your script file using [AStyle](http://astyle.sourceforge.net/).
```
AStyle --style=allman <your-file>
```

## General
Double slash `//` is used for comments. C style `/* ... */` is not supported.  

Names cannot have spaces or begin with a number.  


## Classes
Classes are supported (see `airport.neb`).
```c#
class klass
{
    public void DoIt(int val)
    {
        Print("DoIt got:", val);
    }
}    
```


# Script API

What the script supports.

## Basics

### Time
Time uses the `BarTime` class. A shorthand is provided to specify a time using `var mytime = new BarTime(2.3)` where the
left of the decimal point is beats and the right is subdivs in the range of 0 to 7.

Neb doesn't care about measures, that's up to you.

Some pieces work better with absolute time so scripts have access to a `Now` property that supplies the number of seconds since the start button was pressed.

### Devices and Protocols
Midi and OSC are supported by Nebulator (or at least reasonable subsets). Devices are specified in the settings file:

- MidiInput: Midi in port name on your machine.
- MidiOutput: Midi out port name on your machine.
- OscInput: As `OSC:1234` where `1234` is the local port number.
- OscOutput: As `OSC:127.0.0.1:1234` where `127.0.0.1` is the endpoint IP and `1234` is the port number.

Since the built-in Windows GM player sounds terrible, there are a couple of options for playing midi locally:

- Replace it with [virtualmidisynth](https://coolsoft.altervista.org/en/virtualmidisynth) and your favorite soundfont.
- If you are using a DAW for sound generation, you can use a virtual midi loopback like [loopMIDI](http://www.tobias-erichsen.de/software/loopmidi.html) to send to it.

### Musical Notes/Chords/Scales
Scales and chords are specified by strings like `"1 4 6 b13"`.
There are many builtin which are listed by running `Show Definitions` from the File menu. This also includes midi definitions.
Users can add their own by using `CreateNotes("FOO", "1 4 6 b13")`.

Notes (single) and note groups (chords, scales) are referenced in several ways:
- "F4" - Named note with octave.
- "F4.o7" - Named chord in the key of middle F.
- "F4.Aeolian" - Named scale in the key of middle F.
- "F4.FOO" - Custom chord or scale created with `CreateNotes()`.
- SideStick - Drum name from the definitions.
- 57 - Simple midi note number.


## Directives

### Include
```c#
#:include some path\utils.neb
```
A simple include mechanism is supplied. It's pretty much an insert-whole-file-body-here, no wildcard support.
If the path is absolute, it is used directly. If not, it is relative to the current file.
It needs to be specified before contents are referenced. If one were to get grandiose, a true import could be implemented.


### Channel
```c#
#:channel chname devid chnum patch
```
Defines an output channel.

- chname: For display in the UI.
- devid: A user-specified device id as entered in the user settings.
- chnum: Channel number to play on.
- patch: Name of the patch.


## Composition
A composition is comprised of one or more Sections each of which has one or more Sequences of notes.
You first create your Sequences like this:
```c#
Sequence CreateSequence(beats, elements[]);
```

There are several ways to do this. (see `example.neb`.)
A list of notes:
```c#
Sequence seq1 = CreateSequence(8, new()
{
    { 0.0, "F4",  0.7, 0.2 },
    { 0.4, "D#4", 1.1, 0.2 },
    { 1.0, "C4",  0.7, 0.2 },
});
```
- 8 is the number of beats in the sequence.
- Notes are `{ when to play in the sequence, note or chord or drum, volume, duration }`. If duration is omitted, it defaults to 0.1, useful for drum hits.

```c#
Sequence seq2 = CreateSequence(8, new()
{
    { "|7-------|--      |        |        |7-------|--      |        |        |", "G4.m7", 0.9  },
    { "|        |        |        |5---    |        |        |        |5-8---  |", "G4.m6", 0.75 },
});
```
- Notes are `{ pattern, note or chord or drum, volume, duration }`.
- Pattern: describes a sequence of notes, kind of like a piano roll. `1 to 9` (volume) starts a note which is held 
  for subsequent `-`. The note is ended with any other character than `-`. `|`, `.` and ` ` are ignored, 
  used for visual assist only. These are particularly useful for drum patterns.

```c#
Sequence seqAlgo = CreateSequence(4, new()
{
    { 1.2, AlgoFunc, 0.8 },
});

void AlgoFunc()
{
    int notenum = Random(0, scaleNotes.Count());
    SendNote("synth", scaleNotes[notenum], 0.7, 0.5);
}
```
- Notes are `{ when, function, volume }`.

Then you group Sequences into Sections, typically things like verse, chorus, bridge, etc.
```c#
Section sectMiddle = CreateSection(32, "Middle", new()
{
    { "keys",  seqKeysChorus  },
    { "drums", seqDrumsChorus },
    { "bass",  seqBassChorus  },
    { "synth", seqAlgo, seqEmpty, seqAlgo, seqDynamic, seqEmpty }
});
```
- beats: Overall length in beats.
- name: Displayed in time control while playing.
- sequences: 1 to N descriptors of which sequences to play sequentially. They are played in order and repeat to fill the section.

## Runtime

### Properties
Accessible or modified in the script.

```c#
bool Playing
```
Indicates that script is executing. Read only.

```c#
BarTime StepTime
```
Current Nebulator step time object. Read only. Also use for StepTime.Beat and StepTime.subdiv.

```c#
double RealTime
```
Seconds since playing started. Read only.

```c#
double Speed
```
Nebulator speed in BPM. Read/write.

```c#
int MasterVolume
```
Nebulator master volume. Read/write.


### Callback Functions
These can be overridden in the user script.

```c#
public override void Setup();
```
Called once to initialize your script stuff.

```c#
public override void Step();
```
Called every Subdiv.

```c#
public override void InputNote(dev, chnum, note, vel);
```
Called when input note arrives.

- dev: DeviceType.
- chnum: Channel number.
- note: Note number.
- vel: velocity

```c#
public override void InputControl(dev, chnum, ctlid, value);
```
Called when input controller arrives.
- dev: DeviceType.
- chnum: Channel number.
- ctlid: ControllerDef.
- value: Controller value.


### Send Functions
Call these from inside your script.

```c#
void SendNote("chname", note, vol, dur)
```
Send a note immediately. Respects solo/mute. Adds a note off to play after dur time.

- chname: Channel name to send it on.
- note: One of the note definitions.
- vol: Note volume. Normalized to 0.0 - 1.0. 0.0 means note off.
- dur: How long it lasts in beats or BarTime object representation.

```c#
void SendNoteOn("chname", note, vol)
```
Send a note on immediately. Respects solo/mute. Doesn't add note off.

- chname: Channel name to send it on.
- note: One of the note definitions.
- vol: Note volume. Normalized to 0.0 - 1.0.

```c#
void SendNoteOff("chname", note)
```
Send a note off immediately.

- chname: Channel name to send it on.
- note: One of the note definitions.

```c#
void SendController("chname", ctl, val)
```
Send a controller immediately. Useful for things like panning and bank select.

- chname: Channel name to send it on.
- ctl: Controller name from the definitions or const() or simple integer.
- val: Controller value.

```c#
void SendPatch("chname", patch)
```
Send a midi patch immediately. Really only needed if using the windows GM.

- chname: Channel name to send it on.
- patch: Instrument name from the definitions.

### Utilities

```c#
void Print(object arg, object arg, ...);
```
You know what this is.

```c#
void CreateNotes("name", "parts")
```
Define a group of notes for use as a note, or in a chord or scale.

- name: Reference name.
- note: List of note definitions.

```c#
List<double> GetNotes("scale_or_chord", "key")
```
Get an array of scale or chord notes.

- scale: One of the named scales from ScriptDefinitions.md or defined in `notes`.
- key: Note name and octave.
- returns: Array of notes or empty if invalid.


# Internals

- Uses Roslyn for in-memory compilation.
- No installer yet, it's a build-it-yerself for now. Eventually a nuget package might be created.
- Settings and log are in `C:\Users\<user>\AppData\Local\Ephemera\Nebulator`.

## Design

- `Script.csproj` is compiled separately into an assembly so it can be linked with the user script.
- Main UI and non user script stuff is all in the `App` project.
- Channels and Controllers follow the midi model.
- IOutputDevices represent ports (and corresponding physical dvices.)
- You can have up to 16 Channels per each IOutputDevice.


## Midi Controllers

Nebulator adds a couple of (unused) controller values for internal use.

Controller          | Number |
----------          | ------ |
NoteControl         | 250    |
PitchControl        | 251    |

